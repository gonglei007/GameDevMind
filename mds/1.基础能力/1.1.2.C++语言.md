<h2 align="center">C++语言</h2>
<p>
C++是一个历史悠久、应用广泛的编程语言，在前端开发、后端开发、工具开发等都有广泛的应用。
</p>

**关键词:**<br/>
*C++,指针,内存越界,引用,模板,STL,内存泄露*

**标签:**<br/>
*等级: 初级|中级, 阶段: 学习|开发, 分类: 基础能力, 角色: 客户端开发|服务端开发*

----
## 目录

- [目录](#目录)
- [语言应用](#语言应用)
- [数据类型](#数据类型)
- [指针](#指针)
- [指针与数组](#指针与数组)
  - [区别](#区别)
- [引用](#引用)
- [字符串](#字符串)
- [智能指针](#智能指针)
  - [类型](#类型)
  - [内部实现](#内部实现)
- [内存](#内存)
- [内存分布](#内存分布)
- [条件语句](#条件语句)
- [STL（标准模板库）](#stl标准模板库)
  - [容器](#容器)
- [模板（template）](#模板template)
- [Bit masking](#bit-masking)
- [cast](#cast)
- [宏](#宏)
- [inline](#inline)
- [库文件](#库文件)
  - [静态库](#静态库)
  - [动态库](#动态库)
- [编译器](#编译器)
- [更多资料](#更多资料)
  - [训练资料](#训练资料)
  - [在线资料](#在线资料)
  - [视频资料](#视频资料)
  - [培训](#培训)

----

## 语言应用

**是什么？在哪用？**
- **为什么选择C++来开发游戏？**
  - C++够"低级"，它允许你控制所有底层的东西，比如内存、指令、硬件。你几乎可以知道你的一段代码编程CPU指令后是什么样的
  - C++开发效率不是那么高，因为你有很多的细节要自己去控制把握。但它的运行效率非常的高（只要你掌握的足够好、优化的足够好）。甚至一些主机硬件会针对C++做优化
  - 如果你的应用场景是需要你的程序、模块、系统高度优化（可能是硬件限制、可能是成本考量），就可以考虑使用C++语言

- **游戏开发中可能有哪些场景会使用C++？**
  - **引擎开发**：引擎的运行时库是需要最大化的运行效率的
  - **服务器开发**：在用户量大的时候，尽力发挥每台服务器的效能，提高性价比
  - **工具开发**：有些高性能需求工具，可以考虑用C++进行开发

## 数据类型

**是什么？在哪用？**
- **作用**：C++提供了丰富的数据类型，包括基本类型、复合类型等
- **应用场景**：所有需要存储和操作数据的场景
- **常用类型**：
  - **整数类型**：int、long、long long等
  - **浮点类型**：float、double、long double
  - **字符类型**：char、wchar_t
  - **布尔类型**：bool
  - **复合类型**：数组、结构体、类等

**会遇到哪些问题？用什么解决？**
- **溢出问题**
  - **问题**：整形运算的值超出了32位，在32位的系统上，有个跟时间增长相关的变量，程序跑半个月，数值就可能溢出了，就会产生相关的bug
  - **解决方向**：
    - 注意运算顺序，例如 `D = A * B / C` 改为 `D = A / C * B` 更安全一点
    - 使用更大的数据类型（如long long）
    - 使用溢出检查（如 `std::numeric_limits`）
    - 对于时间相关变量，使用专门的时间类型

- **精度问题**
  - **问题**：数字太小（小数位太多） - 小数点后N位就无法正确计算了。图形编程中的Z闪烁就是精度问题导致的
  - **解决方向**：
    - 根据精度需求选择合适的浮点类型（float约7位有效数字，double约15位）
    - 注意浮点数的精度限制，避免精度丢失
    - 在图形编程中，考虑使用double或定点数
    - 避免直接比较浮点数相等，使用误差范围比较

- **有损截断（Lossy Narrowing/Truncation）**
  - **问题**：当用高精度数据类型给低精度数据类型赋值的时候，数据会被破坏性的转化
  - **解决方向**：
    - 使用 `narrow_cast` 等安全的类型转换方法，明确标识可能的数据损失
    - 使用 `static_cast` 进行显式转换
    - 在转换前检查数据范围，避免数据丢失
    - 使用编译器的警告选项（如 `-Wnarrowing`）

**要点和思考方向**
- 根据数据范围选择合适的整数类型
- 根据精度需求选择合适的浮点类型
- 注意类型转换的安全性，避免数据丢失
- 使用现代C++的类型安全转换方法

## 指针

**是什么？在哪用？**
- **说明**：指针是一个变量，这个变量存储的内容是一个地址，指向内存的一个存储单元
- **意义**：指针可以让你只动结构，不动内容。也就是说，可以只换门牌号，而不用让人去搬家

**会遇到哪些问题？用什么解决？**
- **野指针（Wild Pointer/Dangling Pointer）**
  - **问题**：指针变量原来指向的变量/对象释放了，这块内存可能被释放了，也可能后来又被分配它用了。这时候这个指针还在，如果再针对这个指针所指的地址做原来的那些操作，事情就乱套了
  - **解决方向**：
    - 指针释放后及时置空（`ptr = nullptr`）
    - 使用智能指针管理内存生命周期
    - 避免返回局部变量的指针
    - 使用RAII原则管理资源

- **空指针（Null Pointer）**
  - **问题**：使用空指针访问数据导致程序崩溃
  - **解决方向**：
    - 在使用指针前检查是否为空
    - 使用引用替代指针（如果可能）
    - 使用智能指针的 `get()` 方法前检查

- **指针算术错误**
  - **问题**：指针算术运算错误，导致访问越界
  - **解决方向**：
    - 注意指针类型，不同类型的指针步进距离不同
    - 使用数组索引而非指针算术（如果可能）
    - 使用STL容器替代原始数组

**要点和思考方向**
- 指针可以让你只动结构，不动内容，提高效率
- 指针释放后要及时置空，避免野指针
- 优先使用智能指针，自动管理内存生命周期
- 使用指针前要检查是否为空
- 理解指针和引用的区别，选择合适的类型

## 指针与数组

**是什么？在哪用？**
- **作用**：理解指针和数组的关系，正确使用指针访问数组
- **应用场景**：数组操作、内存访问、性能优化
- **关系**：数组名在大多数情况下会退化为指向首元素的指针

### 区别

- **sizeof**：用于计算数据大小，指针和数组的 sizeof 结果不同
  - 数组的sizeof返回整个数组的大小
  - 指针的sizeof返回指针本身的大小（通常4或8字节）
- **指针运算**：`char : v+1` 与 `pointer: v+1` 的步进距离不同
  - char类型指针+1，步进1字节
  - int类型指针+1，步进4字节（假设int是4字节）

**会遇到哪些问题？用什么解决？**
- **数组退化为指针**
  - **问题**：数组作为函数参数时会退化为指针，丢失大小信息
  - **解决方向**：
    - 使用模板函数保留数组大小信息
    - 传递数组大小作为额外参数
    - 使用 `std::array` 或 `std::vector` 替代原始数组

- **数组越界**
  - **问题**：使用指针访问数组时容易越界
  - **解决方向**：
    - 使用数组索引而非指针算术
    - 使用STL容器（如vector）替代原始数组
    - 添加边界检查

**要点和思考方向**
- 理解指针和数组在内存访问上的不同行为
- 注意sizeof对指针和数组的不同结果
- 数组作为函数参数时会退化为指针
- 优先使用STL容器替代原始数组

## 引用

**是什么？在哪用？**
- **作用**：相当于一个变量的别名，它本身不占用额外的内存
- **应用场景**：
  - 函数参数传递（避免拷贝开销）
  - 避免指针的空指针问题
  - 函数返回值（返回引用避免拷贝）
  - 范围for循环

**会遇到哪些问题？用什么解决？**
- **返回局部变量的引用**
  - **问题**：返回局部变量的引用，导致悬空引用
  - **解决方向**：
    - 不要返回局部变量的引用
    - 返回静态变量、全局变量或动态分配对象的引用
    - 使用值返回或智能指针

- **引用初始化后不能重新绑定**
  - **问题**：引用必须在初始化时绑定，之后不能改变
  - **解决方向**：
    - 理解引用的特性，不能重新绑定
    - 如果需要改变指向，使用指针
    - 在初始化时就绑定正确的对象

- **指针的引用和变量的引用混淆**
  - **问题**：指针的引用和变量的引用在使用上有区别，容易混淆
  - **解决方向**：
    - 明确理解引用的类型
    - 指针的引用是引用的指针，变量的引用是引用的变量
    - 使用类型别名（using/typedef）提高可读性

**要点和思考方向**
- 引用是变量的别名，不占用额外内存
- 引用必须在初始化时绑定，之后不能改变
- 不要返回局部变量的引用
- 理解引用和指针的区别，选择合适的类型
- 引用通常用于函数参数传递，避免拷贝开销

## 字符串

**是什么？在哪用？**
- **作用**：存储和操作文本数据
- **应用场景**：所有需要处理文本的场景
- **类型**：
  - **C风格字符串**：`char*` 或 `char[]`，以 `\0` 结尾
  - **C++字符串**：`std::string`，自动管理内存

**会遇到哪些问题？用什么解决？**
- **长度问题**
  - **问题**：字符串长度计算和边界处理容易出错
  - **解决方向**：
    - 使用 `std::string` 替代C风格字符串
    - 使用 `std::string::size()` 或 `std::string::length()` 获取长度
    - 注意 `strlen()` 不包括 `\0`，但 `sizeof()` 包括
    - 使用范围for循环遍历字符串

- **字符类型 vs 字符串类型**
  - **问题**：`"a"` 与 `'a'` 的区别，一个是字符串，一个是字符，容易混淆
  - **解决方向**：
    - `'a'` 是字符（char），占用1字节
    - `"a"` 是字符串（const char*），包含字符'a'和'\0'，占用2字节
    - 明确区分字符和字符串的使用场景

- **字符串越界**
  - **问题**：C风格字符串容易越界，导致缓冲区溢出
  - **解决方向**：
    - 使用 `std::string` 替代C风格字符串
    - 使用安全的字符串函数（如 `strncpy`、`strncat`）
    - 添加边界检查

- **字符串拼接性能**
  - **问题**：频繁的字符串拼接导致性能问题
  - **解决方向**：
    - 使用 `std::string::append()` 或 `+=` 操作符
    - 使用 `std::ostringstream` 进行复杂拼接
    - 预分配字符串容量（`reserve()`）

**要点和思考方向**
- 优先使用 `std::string` 替代C风格字符串
- 注意字符和字符串的区别
- 注意字符串长度计算，避免越界
- 理解C风格字符串以 `\0` 结尾的特性

## 智能指针

**是什么？在哪用？**
- **作用**：解决内存泄露的问题，自动管理对象生命周期
- **应用场景**：
  - 自动管理对象生命周期
  - 避免手动 new/delete 导致的内存泄漏
  - 资源管理（RAII）
  - 异常安全

### 类型

- **std::unique_ptr**：独占所有权的智能指针
  - 不能复制，只能移动
  - 适合单一所有者场景
- **std::shared_ptr**：共享所有权的智能指针
  - 使用引用计数
  - 适合多个所有者场景
- **std::weak_ptr**：弱引用智能指针
  - 不增加引用计数
  - 用于打破循环引用

### 内部实现

- 重载了 `*` 和 `->` 运算符
- 通过引用计数（shared_ptr）或所有权转移（unique_ptr）来判断对象是否在用
- 超出范围时自动释放内存

**会遇到哪些问题？用什么解决？**
- **循环引用**
  - **问题**：shared_ptr之间的循环引用导致内存泄漏
  - **解决方向**：
    - 使用 `weak_ptr` 打破循环引用
    - 重新设计对象关系，避免循环引用
    - 使用 `unique_ptr` 替代 `shared_ptr`（如果可能）

- **性能开销**
  - **问题**：智能指针有性能开销（引用计数、虚函数调用等）
  - **解决方向**：
    - 在性能关键路径上考虑使用原始指针（但要确保安全）
    - 使用 `unique_ptr` 而非 `shared_ptr`（如果可能）
    - 避免不必要的智能指针拷贝

- **原始指针混用**
  - **问题**：智能指针和原始指针混用，导致所有权混乱
  - **解决方向**：
    - 明确所有权，使用智能指针管理资源
    - 避免在智能指针管理的对象上使用原始指针
    - 使用 `get()` 方法获取原始指针时要小心

**要点和思考方向**
- 优先使用智能指针管理动态分配的内存
- 理解不同智能指针的适用场景
- 注意循环引用问题，使用 `weak_ptr` 打破循环
- 在性能关键路径上考虑性能开销
- 避免智能指针和原始指针混用

## 内存

**会遇到哪些问题？用什么解决？**
- **写内存越界**
  - **问题**：C/C++的特点是"自由"，它不管你怎么读写内存，想写到哪里都可以
  - **危害**：
    - 很难知道什么东西被写坏了
    - 很难知道被什么写坏了
    - 错误表现通常无厘头
  - **容易出现越界的操作**：字符串操作、内存操作、指针操作
  - **解决方向**：使用安全的字符串函数，边界检查，使用容器替代原始数组

- **内存泄露**
  - **问题**：分配的内存没有正确释放
  - **排查**：借用工具来排查内存泄露
  - **解决方向**：可通过使用智能指针来避免内存泄露

- **内存碎片**
  - **问题**：运行时持续的分配、释放内存，这样会产生内存碎片
  - **解决方向**：使用内存池来管理内存分配

- **内存对齐**
  - **说明**：CPU一次取一批数据，CPU取数据的位置是有对齐规则的
  - **为什么对齐**：为了CPU的数据读取性能
  - **应用场景**：优化内存使用、对象序列化

**是什么？在哪用？**
- **作用**：理解内存布局，优化内存使用和性能
- **应用场景**：
  - 计算内存数据长度
  - 调试指针指向
  - 性能优化
  - 内存对齐优化

## 内存分布

- **栈（Stack）**：局部变量、函数参数，自动管理
- **堆（Heap）**：动态分配的内存，手动管理
- **全局/静态区**：全局变量、静态变量
- **代码区**：程序代码

**要点和思考方向**
- 理解不同内存区域的特点和用途
- 栈内存自动管理，堆内存需要手动管理
- 注意栈空间有限，不适合大对象
- 使用内存分析工具调试内存问题

## 条件语句

**会遇到哪些问题？用什么解决？**
- **代码块遗漏大括号**
  - **问题**：单行 if 语句容易导致逻辑错误
  - **解决方向**：为了减少bug出现几率，尽量都是用 `{}` 括起来

## STL（标准模板库）

**是什么？在哪用？**
- **作用**：提供常用的数据结构和算法，提高开发效率
- **应用场景**：
  - 事件系统
  - 对象管理
  - 数据处理
  - 算法实现

### 容器

- **vector**：动态数组，支持随机访问
- **list**：双向链表，支持高效插入删除
- **deque**：双端队列
- **queue**：队列，FIFO
- **stack**：栈，LIFO
- **map**：内部是根据key（红黑树）排序的。如果需要对顺序数据排序，可以借用
- **unordered_map**：哈希表，O(1)查找
- **set**：有序集合
- **unordered_set**：无序集合

**会遇到哪些问题？用什么解决？**
- **性能问题**
  - **问题**：容器在运行时动态扩容会导致内存的动态分配和碎片，进而影响性能
  - **解决方向**：
    - 尽量在初始化的时候，就把容器的可能空间确定好（使用 `reserve()`）
    - 这样可以减少在运行时动态的给容器扩容
    - 选择合适的容器类型（如vector vs list）
    - 使用 `emplace` 而非 `push`（避免不必要的拷贝）

- **迭代器失效**
  - **问题**：在修改容器时，迭代器可能失效
  - **解决方向**：
    - 理解不同容器的迭代器失效规则
    - 在修改容器后重新获取迭代器
    - 使用索引而非迭代器（如果可能）

- **容器选择不当**
  - **问题**：选择不合适的容器类型，导致性能问题
  - **解决方向**：
    - 根据使用场景选择合适的容器
    - vector适合随机访问，list适合频繁插入删除
    - map适合有序查找，unordered_map适合快速查找
    - 考虑时间和空间复杂度

**要点和思考方向**
- 根据使用场景选择合适的容器类型
- 使用 `reserve()` 预分配空间，减少动态扩容
- 理解迭代器失效规则，避免使用失效的迭代器
- 使用现代C++特性（如emplace、范围for循环）
- 注意容器的性能特征，选择合适的操作

## 模板（template）

**是什么？在哪用？**
- **作用**：实现对不同类型数据的统一管理，提供类型安全的泛型编程
- **应用场景**：
  - **容器**：存储不特定类型的数据（对象）
  - **事件机制**：处理不同类型的事件
  - **3D数据处理**：比如mesh的顶点数据可能有不同的数据类型，但对这些数据进行的操作是相同的
  - **算法**：实现通用的算法，适用于不同类型

**会遇到哪些问题？用什么解决？**
- **编译错误信息复杂**
  - **问题**：模板编译错误信息复杂，难以理解
  - **解决方向**：
    - 使用 `static_assert` 提供清晰的错误信息
    - 使用 `concepts`（C++20）约束模板参数
    - 分步编译，逐步定位错误

- **代码膨胀**
  - **问题**：模板会为每种类型生成代码，导致代码膨胀
  - **解决方向**：
    - 使用显式实例化（explicit instantiation）
    - 将模板实现移到源文件（如果可能）
    - 注意模板的实例化数量

- **模板特化复杂**
  - **问题**：模板特化规则复杂，容易出错
  - **解决方向**：
    - 理解模板特化的规则和优先级
    - 使用 `if constexpr`（C++17）简化特化
    - 使用 `concepts`（C++20）替代部分特化

**要点和思考方向**
- 模板提供类型安全的泛型编程
- 理解模板实例化和特化规则
- 注意代码膨胀问题，合理使用模板
- 使用现代C++特性简化模板代码

## Bit masking

**是什么？在哪用？**
- **作用**："多快好省"的存储和操作数据，使用位操作高效管理多个布尔状态
- **应用场景**：
  - 多开关状态存储（如游戏中的buff/debuff状态）
  - 标志位管理
  - 权限管理
  - 性能优化（减少内存占用）

**会遇到哪些问题？用什么解决？**
- **可读性差**
  - **问题**：位操作代码可读性差，难以理解
  - **解决方向**：
    - 使用枚举或常量定义位掩码
    - 使用有意义的名称
    - 添加注释说明位操作的含义

- **类型安全问题**
  - **问题**：位操作容易出错，类型不安全
  - **解决方向**：
    - 使用 `std::bitset` 替代原始位操作
    - 使用强类型枚举（enum class）
    - 封装位操作为函数

**要点和思考方向**
- 位操作速度快、省内存，适合多状态管理
- 使用枚举或常量提高可读性
- 考虑使用 `std::bitset` 提高类型安全
- 注意位操作的优先级，使用括号明确

## cast

**是什么？在哪用？**
- **作用**：类型转换。不同于强制类型转换，使用cast转换会对转化类型进行检查
- **应用场景**：需要类型转换的场景，提供类型安全的转换
- **类型**：
  - **static_cast**：静态转换，编译时检查
  - **dynamic_cast**：动态转换，运行时检查（用于多态）
  - **const_cast**：去除const属性
  - **reinterpret_cast**：重新解释类型（危险，慎用）

**会遇到哪些问题？用什么解决？**
- **不安全的类型转换**
  - **问题**：使用C风格强制转换，不安全
  - **解决方向**：
    - 使用C++的cast替代C风格转换
    - 选择合适的cast类型
    - 避免使用 `reinterpret_cast`（除非必要）

- **dynamic_cast性能开销**
  - **问题**：dynamic_cast有运行时开销
  - **解决方向**：
    - 在性能关键路径上减少dynamic_cast使用
    - 使用虚函数替代dynamic_cast（如果可能）
    - 缓存转换结果（如果重复使用）

**要点和思考方向**
- 使用C++的cast替代C风格强制转换
- 选择合适的cast类型，避免不安全的转换
- dynamic_cast用于多态类型转换，有运行时开销
- 避免使用 `reinterpret_cast`，除非必要

## 宏

**是什么？在哪用？**
- **作用**：在预处理阶段进行文本替换，实现条件编译和代码生成
- **应用场景**：
  - 编译配置中可以针对不同的编译平台配置不同的宏
  - 版本平台差异的区分
  - 条件编译
  - 代码生成

**会遇到哪些问题？用什么解决？**
- **宏展开问题**
  - **问题**：宏只是将其定义的那段字符串展开到使用的代码位置，所以它定义的内容不能被当成一个整体来处理，本身也无语法定义。结果如何是看被展开以后，那个地方的整体代码的效果
  - **解决方向**：
    - 使用括号保护宏定义
    - 使用 `do { ... } while(0)` 包裹多行宏
    - 优先使用 `constexpr`、`inline` 函数替代宏

- **调试困难**
  - **问题**：宏在预处理阶段展开，调试困难
  - **解决方向**：
    - 使用编译器选项查看宏展开结果
    - 避免复杂的宏定义
    - 使用函数替代复杂宏

- **命名冲突**
  - **问题**：宏命名冲突，导致意外的文本替换
  - **解决方向**：
    - 使用命名空间或前缀避免冲突
    - 使用全大写命名宏
    - 及时取消宏定义（#undef）

**要点和思考方向**
- 宏在预处理阶段展开，要注意括号和优先级
- 优先使用现代C++特性（constexpr、inline）替代宏
- 避免复杂的宏定义，使用函数替代
- 注意宏命名冲突，使用合适的命名规范

## inline

**是什么？在哪用？**
- **作用**：inline的函数会在调用的地方被展开，相当于把函数内的代码插入到调用的地方
- **应用场景**：
  - 小函数，频繁调用
  - 性能关键路径
  - 头文件中的函数定义

**会遇到哪些问题？用什么解决？**
- **inline不生效**
  - **问题**：编译器可能忽略inline建议，不进行内联
  - **解决方向**：
    - inline只是建议，编译器决定是否内联
    - 函数太复杂或包含循环，可能不会内联
    - 使用编译器选项强制内联（如 `__forceinline`）

- **代码膨胀**
  - **问题**：过度使用inline导致代码膨胀
  - **解决方向**：
    - 只对小的、频繁调用的函数使用inline
    - 注意代码大小和性能的平衡
    - 使用 `__attribute__((always_inline))` 时要谨慎

**要点和思考方向**
- inline只是建议，编译器决定是否内联
- 如果一个函数比较小，在代码中又多次调用，可以加inline
- 注意代码膨胀问题，不要过度使用inline
- 现代编译器通常能自动内联，不一定需要显式指定

## 库文件

**是什么？在哪用？**
- **作用**：库文件可以理解为一个模块/系统的封装，提供代码复用和模块化
- **应用场景**：
  - 代码复用
  - 模块化开发
  - 第三方库集成

### 静态库

**是什么？在哪用？**
- **作用**：给程序编译用的，链接时直接嵌入到可执行文件中
- **应用**：如果你的库是想给不同的开发者拿去集成功能的，就做成静态库
- **特点**：
  - 编译时链接
  - 可执行文件包含库代码
  - 不需要运行时库文件

**会遇到哪些问题？用什么解决？**
- **代码重复**
  - **问题**：多个程序使用静态库，库代码会被重复包含
  - **解决方向**：
    - 使用动态库减少代码重复
    - 注意静态库的大小

**要点和思考方向**
- 静态库在编译时链接，可执行文件包含库代码
- 适合给开发者集成功能
- 注意代码重复问题

### 动态库

**是什么？在哪用？**
- **作用**：给程序运行用的，运行时动态加载
- **应用**：如果你的库是想给不同的程序去运行调用的，就做成动态库
- **特点**：
  - 运行时链接
  - 多个程序共享同一个库文件
  - 需要运行时库文件存在

**会遇到哪些问题？用什么解决？**
- **版本兼容性**
  - **问题**：动态库版本更新可能导致兼容性问题
  - **解决方向**：
    - 使用版本号管理库版本
    - 保持ABI兼容性
    - 使用符号版本控制

- **依赖问题**
  - **问题**：程序依赖动态库，运行时找不到库文件
  - **解决方向**：
    - 确保库文件在系统路径中
    - 使用相对路径或环境变量
    - 提供安装脚本

**要点和思考方向**
- 动态库在运行时链接，多个程序共享
- 适合给不同程序调用
- 注意版本兼容性和依赖问题

## 编译器

**是什么？在哪用？**
- **过程**：编译、链接
- **Makefile**：
  - **作用**：一个工程有大量的文件，文件之间有各种依赖关系。makefile就是用来配置这个关系的，然后告诉编译器如何来编译这些文件并产生结果
  - **补充说明**：有些IDE把这些文件关系都集成到IDE的（图形界面中的）工程管理配置中去了

- **可选择的C++编译器**：
  - **gcc**：支持交叉编译（在一个平台上编译生成在另一个平台上运行的可执行文件）
  - **mingw**
  - **clang**

**会遇到哪些问题？用什么解决？**
- **编译链接警告**
  - **问题**：警告通常会反应出来潜在的bug
  - **解决方向**：尽量将警告视为错误，去处理掉它！

## 更多资料

### 训练资料
* [【推荐】C++找bug训练](https://github.com/gonglei007/cpp-bugs-killer) - 一个有意思的C++训练项目，通过分析代码bug来熟悉C++语言的特性。里面提供了很多种C++的bug示例代码。
* [Program Bug Examples](https://courses.cs.vt.edu/~cs2204/summer2004/readings/bugexamples.htm)

### 在线资料
* [如何设计内存池？](https://www.zhihu.com/question/25527491/answer/2629173868)
* [C++ 智能指针最佳实践&源码分析](https://zhuanlan.zhihu.com/p/436290273) - 介绍智能指针可以解决的问题，用法及最佳实践。并且根据源码分析智能指针的实现原理。
* [Smart Pointers in C++ and How to Use Them](https://www.geeksforgeeks.org/smart-pointers-cpp/) - 讨论 C++ 中的智能指针。什么是智能指针，为什么以及如何正确使用它们？
* [C++中Crash定位原理与常见案例反汇编分析](https://zhuanlan.zhihu.com/p/412102389) - 本文主要C++中crash解析定位原理，讨论为什么能解析出堆栈？如何找到函数名称？如何定位出C++源文件的行号？crash时寄存器值有什么意义？以及遇到crash时如何应对。
* [游戏开发面试答案篇（一）-- C++篇](https://mp.weixin.qq.com/s/A2rIUY10fd8inNbBRdzzXg)
* [C++ core guideline ES.46: Avoid lossy (narrowing, truncation) arithmetic conversion](https://blog.fearcat.in/a?ID=01750-ce228fbb-e010-4b9a-93d1-2a56247a5bfc) - 关于避免有损截断的指南
 
### 视频资料
* [你应该掌握的10个现代 C++ 特性](https://www.youtube.com/watch?v=y6widqVUlb4)

### 培训
* [Boolan](http://boolan.com) - C++培训
