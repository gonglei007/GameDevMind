<h2 align="center">算法</h2>
<p>
正确的使用算法，可以大幅度的提高程序运行的效率，或者解决一些复杂的问题。
</p>

**关键词:**<br/>
*Algorithm,sort,search,算法,排序,查找,复杂度,分治法,动态规划,贪心算法*

**标签:**<br/>
*等级: 初级|中级, 阶段: 学习|开发, 分类: 基础能力, 角色: 客户端开发|服务端开发|全栈开发*

----
## 目录

- [复杂度](#复杂度)
- [时间复杂度](#时间复杂度)
- [应用举例](#应用举例)
- [排序](#排序)
- [方法](#方法)
- [应用举例](#应用举例)
- [查找](#查找)
- [方法](#方法)
- [应用举例](#应用举例)
- [搜索](#搜索)
- [深度优先搜索（DFS）](#深度优先搜索dfs)
- [广度优先搜索（BFS）](#广度优先搜索bfs)
- [应用举例](#应用举例)
- [填充算法（Hole-Filling）](#填充算法hole-filling)
- [算法](#算法)
- [应用举例](#应用举例)
- [实现](#实现)
- [递归方法](#递归方法)
- [应用举例](#应用举例)
- [迭代方法](#迭代方法)
- [模式](#模式)
- [分治法](#分治法)
- [动态规划法](#动态规划法)
- [贪心算法](#贪心算法)
- [线性规划](#线性规划)
- [更多资料](#更多资料)
- [在线资料](#在线资料)
- [视频资料](#视频资料)
- [电子文档](#电子文档)
- [题库](#题库)

----

## 复杂度

## 时间复杂度

**是什么？在哪用？**
- **作用**：衡量算法执行时间随输入规模增长的变化趋势
- **应用场景**：
  - 算法设计和选择
  - 性能评估和优化
  - 系统设计时的权衡考虑
- **应用**：在设计系统的时候，可以根据实际需求，思考用时间换空间或者用空间换时间

## 应用举例

- **预计算 vs 实时计算**
  - **场景**：如果是要用到一个有限的数列，并且这个地方的性能要求比较高
  - **方案**：可以考虑不去计算出来这个数列的各个值，而是预先将它们存储到一个数组中来使用
  - **权衡**：用空间换时间，提高运行效率

**会遇到哪些问题？用什么解决？**
- **复杂度分析不准确**
  - **问题**：实际复杂度可能与理论分析不符
  - **解决方向**：
    - 考虑常数因子和低阶项
    - 实际测试验证性能
    - 分析最坏、平均、最好情况
    - 考虑实际数据特征

- **空间复杂度忽略**
  - **问题**：只关注时间复杂度，忽略空间复杂度
  - **解决方向**：
    - 同时分析时间和空间复杂度
    - 根据资源限制选择算法
    - 考虑内存受限场景

**要点和思考方向**
- 复杂度分析帮助选择合适的算法
- 在时间和空间之间权衡，根据实际需求选择
- 考虑实际数据特征，理论分析需要实际验证
- 注意常数因子，小规模数据可能简单算法更快

## 排序

**是什么？在哪用？**
- **作用**：将数据按照某种规则重新排列
- **应用场景**：
  - 数据展示（排行榜）
  - 优化查找性能
  - 预处理数据
  - 算法辅助步骤

## 方法

- **冒泡排序**：简单但效率低，适合小规模数据（O(n²)）
- **选择排序**：每次选择最小（或最大）元素（O(n²)）
- **插入排序**：适合部分有序的数据（O(n²)，最好O(n)）
- **快速排序**：平均性能好，广泛使用（平均O(n log n)，最坏O(n²)）
- **归并排序**：稳定排序，适合大规模数据（O(n log n)）
- **堆排序**：使用堆数据结构排序（O(n log n)）
- **计数排序**：适合范围较小的整数排序（O(n+k)）

## 应用举例

- **游戏排行榜**
  - **需求**：为了保证排行榜的准确性和及时性，需要对玩家分数进行排序
  - **算法选择**：常用的排序算法有快速排序、归并排序等

- **碰撞检测**
  - **需求**：对于每个物体，需要找到它可能会碰撞的其他物体，以便进行碰撞检测
  - **问题**：如果使用暴力枚举的方法，时间复杂度会非常高
  - **方案**：可以将物体按照位置或其他属性进行排序，然后只检测相邻的物体之间的碰撞

- **搜索算法**
  - **需求**：在游戏中，经常需要搜索最优解，例如在迷宫中寻找出口、在地图中寻找最短路径等
  - **说明**：搜索算法的效率很大程度上取决于排序算法的效率。例如，如果使用启发式搜索算法，需要对搜索队列进行排序

- **AI决策**
  - **需求**：在游戏中，AI经常需要进行决策
  - **方案**：如果AI决策的依据是某种评估函数，那么可以将可能的决策按照评估值进行排序，然后选取评估值最高的决策作为AI的决策

**会遇到哪些问题？用什么解决？**
- **算法选择不当**
  - **问题**：选择不合适的排序算法，导致性能问题
  - **解决方向**：
    - 根据数据规模选择算法
    - 小规模数据使用简单算法（插入排序）
    - 大规模数据使用高效算法（快速排序、归并排序）
    - 考虑数据特征（是否部分有序）

- **稳定性要求**
  - **问题**：某些场景需要稳定排序（相等元素相对位置不变）
  - **解决方向**：
    - 使用稳定排序算法（归并排序、插入排序）
    - 在比较函数中加入原始位置信息
    - 使用稳定的排序实现

- **性能问题**
  - **问题**：排序可能成为性能瓶颈
  - **解决方向**：
    - 使用高效的排序算法
    - 增量排序（只排序变化部分）
    - 并行排序（如果适用）
    - 使用标准库的优化实现

**要点和思考方向**
- 根据数据规模和特征选择合适的排序算法
- 注意稳定性要求，选择稳定排序算法
- 小规模数据可能简单算法更快（考虑常数因子）
- 使用标准库的排序实现，通常已经优化

## 查找

**是什么？在哪用？**
- **作用**：在数据集合中定位特定元素
- **应用场景**：
  - 数据检索
  - 玩家匹配
  - 资源查找
  - 缓存查找

## 方法

- **二分查找**：在有序数组中快速查找，时间复杂度 O(log n)
- **散列表查找**：通过哈希表实现快速查找，平均时间复杂度 O(1)
- **树结构查找**：在树结构中查找，如二叉搜索树（O(log n)）
- **线性查找**：顺序遍历查找（O(n)），适合小规模数据

## 应用举例

- **玩家匹配**：快速查找匹配的玩家进行游戏
- **资源管理**：快速查找游戏资源
- **缓存系统**：快速查找缓存数据
- **配置查找**：查找游戏配置项

**会遇到哪些问题？用什么解决？**
- **查找效率低**
  - **问题**：使用线性查找，效率低
  - **解决方向**：
    - 使用二分查找（有序数据）
    - 使用哈希表（键值查找）
    - 使用树结构（动态数据）
    - 建立索引加速查找

- **数据需要排序**
  - **问题**：二分查找需要有序数据，维护成本高
  - **解决方向**：
    - 使用哈希表避免排序
    - 使用自平衡树（如红黑树）
    - 增量排序，只排序变化部分

- **内存开销**
  - **问题**：哈希表和树结构需要额外内存
  - **解决方向**：
    - 小规模数据使用线性查找
    - 使用紧凑的数据结构
    - 权衡内存和性能

**要点和思考方向**
- 根据数据特征选择合适的查找方法
- 有序数据使用二分查找，无序数据使用哈希表
- 小规模数据可能线性查找更快
- 考虑维护成本，选择合适的数据结构

## 搜索

**是什么？在哪用？**
- **作用**：在树或图中查找目标节点或路径
- **应用场景**：
  - 寻路算法
  - 状态空间搜索
  - 树/图遍历
  - 问题求解

## 深度优先搜索（DFS）

**是什么？在哪用？**
- **作用**：沿着树的深度遍历树的节点，尽可能深地搜索树的分支
- **应用场景**：
  - 探索所有可能的路径
  - 回溯算法
  - 拓扑排序
  - 连通性检测
- **特点**：使用栈（递归）实现，可能找到的不是最短路径

**会遇到哪些问题？用什么解决？**
- **栈溢出**
  - **问题**：深度递归可能导致栈溢出
  - **解决方向**：
    - 使用迭代实现DFS
    - 限制搜索深度
    - 使用显式栈

- **非最短路径**
  - **问题**：DFS可能找到的不是最短路径
  - **解决方向**：
    - 如果需要最短路径，使用BFS
    - 使用带深度限制的DFS
    - 使用迭代加深搜索（IDS）

**要点和思考方向**
- DFS适合探索所有路径，不适合找最短路径
- 注意栈溢出问题，使用迭代实现
- 适合回溯和状态空间搜索

## 广度优先搜索（BFS）

**是什么？在哪用？**
- **作用**：从根节点开始，沿着树的宽度遍历树的节点
- **应用场景**：
  - 寻找最短路径
  - 层次遍历
  - 最短路径问题
  - 连通性检测
- **特点**：使用队列实现，能找到最短路径

**会遇到哪些问题？用什么解决？**
- **内存开销**
  - **问题**：BFS需要存储所有待访问节点，内存开销大
  - **解决方向**：
    - 使用双向BFS减少搜索空间
    - 限制搜索范围
    - 使用迭代加深BFS（IDBFS）

- **性能问题**
  - **问题**：大规模图BFS可能很慢
  - **解决方向**：
    - 使用启发式搜索（A*）
    - 并行BFS（如果适用）
    - 优化队列实现

**要点和思考方向**
- BFS适合寻找最短路径
- 注意内存开销，使用双向BFS优化
- 适合无权图的最短路径问题

## 应用举例

- **寻路**：在游戏中寻找从起点到终点的路径
  - **DFS**：适合探索所有可能的路径
  - **BFS**：适合寻找最短路径
- **状态空间搜索**：搜索游戏状态空间
- **连通性检测**：检测图的连通性

## 填充算法（Hole-Filling）

**是什么？在哪用？**
- **作用**：从多边形区域的一个内点开始，由内向外用给定的颜色画点直到边界为止
- **应用场景**：
  - 图像处理
  - 游戏机制实现
  - 地图生成
  - 区域标记

## 算法

- **Lazy flood fill**：延迟填充，优化性能
- **洪水填充**：从起点开始，向四周扩散填充
- **边界填充**：沿着边界进行填充

## 应用举例

- **消除游戏**：消除相同颜色的区域
- **寻路**：标记可达区域
- **地图生成**：生成连续的地形区域
- **画笔功能**：实现填充工具

**会遇到哪些问题？用什么解决？**
- **性能问题**
  - **问题**：大区域填充可能很慢
  - **解决方向**：
    - 使用Lazy flood fill延迟填充
    - 限制填充范围
    - 使用扫描线算法
    - 分块处理大区域

- **栈溢出**
  - **问题**：递归实现可能导致栈溢出
  - **解决方向**：
    - 使用迭代实现
    - 使用队列而非递归
    - 限制递归深度

- **边界检测**
  - **问题**：边界检测可能不准确
  - **解决方向**：
    - 使用精确的边界检测算法
    - 预处理边界信息
    - 使用抗锯齿技术

**要点和思考方向**
- 填充算法适合区域标记和图像处理
- 注意性能问题，使用优化算法
- 使用迭代实现避免栈溢出
- 注意边界检测的准确性

## 实现

## 递归方法

**是什么？在哪用？**
- **作用**：函数调用自身解决问题
- **应用场景**：
  - 树/图遍历
  - 分治算法
  - 回溯算法
  - 问题自然具有递归结构
- **特点**：代码简洁，易于理解
- **问题**：可能栈溢出，性能开销较大

## 应用举例

- **遍历文件目录，批量处理文件**：递归遍历目录树结构
- **快速排序**：递归实现分治
- **深度优先搜索**：递归遍历图

**会遇到哪些问题？用什么解决？**
- **栈溢出**
  - **问题**：深度递归可能导致栈溢出
  - **解决方向**：
    - 使用迭代替代递归
    - 限制递归深度
    - 增加栈空间（如果可能）
    - 使用尾递归优化（如果语言支持）

- **性能开销**
  - **问题**：递归调用有函数调用开销
  - **解决方向**：
    - 使用迭代实现
    - 使用尾递归优化
    - 缓存递归结果（记忆化）

**要点和思考方向**
- 递归代码简洁，但要注意栈溢出
- 深度较大的问题使用迭代
- 简单问题递归更易理解
- 使用尾递归优化减少开销

## 迭代方法

**是什么？在哪用？**
- **作用**：使用循环实现算法
- **应用场景**：
  - 需要高性能的场景
  - 数据规模很大的情况
  - 深度较大的问题
- **特点**：使用循环实现，性能更好，不会栈溢出

**会遇到哪些问题？用什么解决？**
- **代码复杂**
  - **问题**：迭代实现可能比递归复杂
  - **解决方向**：
    - 使用栈/队列模拟递归
    - 提取辅助函数简化代码
    - 添加注释说明逻辑

- **状态管理**
  - **问题**：需要手动管理状态
  - **解决方向**：
    - 使用数据结构（栈/队列）管理状态
    - 使用状态机模式
    - 清晰的状态转换逻辑

**要点和思考方向**
- 迭代方法性能好，不会栈溢出
- 适合高性能和大规模数据场景
- 注意代码复杂度，合理组织代码
- 使用数据结构管理状态

## 模式

## 分治法

**是什么？在哪用？**
- **作用**：将问题分解为多个子问题，递归解决子问题，然后合并结果
- **应用场景**：
  - 问题可以分解为相似的子问题
  - 子问题的解可以合并
  - 适合并行处理
- **应用**：快速排序、归并排序、大整数乘法等

**会遇到哪些问题？用什么解决？**
- **子问题重叠**
  - **问题**：子问题可能重复计算
  - **解决方向**：
    - 使用动态规划避免重复计算
    - 缓存子问题的解
    - 合并相似的子问题

- **合并复杂度**
  - **问题**：合并子问题结果可能复杂
  - **解决方向**：
    - 优化合并算法
    - 简化合并逻辑
    - 使用并行合并（如果适用）

**要点和思考方向**
- 分治法适合可以分解为相似子问题的问题
- 注意子问题重叠，使用动态规划优化
- 优化合并过程，提高整体效率

## 动态规划法

**是什么？在哪用？**
- **作用**：将问题分解为子问题，通过保存子问题的解来避免重复计算
- **应用场景**：
  - 问题具有最优子结构
  - 子问题重叠
  - 需要最优解
- **应用**：最短路径、背包问题、最长公共子序列等

**会遇到哪些问题？用什么解决？**
- **状态定义困难**
  - **问题**：如何定义状态和状态转移方程可能困难
  - **解决方向**：
    - 从简单情况开始分析
    - 使用表格记录状态
    - 参考经典问题的状态定义

- **空间复杂度高**
  - **问题**：需要存储所有子问题的解，空间开销大
  - **解决方向**：
    - 使用滚动数组优化空间
    - 只保存必要的状态
    - 使用记忆化搜索替代DP表

- **边界条件**
  - **问题**：边界条件处理容易出错
  - **解决方向**：
    - 仔细定义初始状态
    - 添加边界检查
    - 使用测试用例验证

**要点和思考方向**
- 动态规划适合具有最优子结构的问题
- 注意空间优化，使用滚动数组
- 仔细定义状态和转移方程
- 注意边界条件处理

## 贪心算法

**是什么？在哪用？**
- **作用**：每一步都做出当前看起来最优的选择，希望最终得到全局最优解
- **应用场景**：
  - 问题具有贪心选择性质
  - 局部最优能导致全局最优
  - 需要快速近似解
- **应用**：最小生成树、最短路径（某些情况）、活动选择问题等
- **注意**：贪心算法不一定能得到全局最优解，需要证明其正确性

**会遇到哪些问题？用什么解决？**
- **不是全局最优**
  - **问题**：贪心算法可能得不到全局最优解
  - **解决方向**：
    - 证明贪心选择性质
    - 使用动态规划验证
    - 接受近似解（如果适用）

- **贪心策略选择**
  - **问题**：如何选择贪心策略可能困难
  - **解决方向**：
    - 分析问题的性质
    - 尝试不同的贪心策略
    - 参考经典问题的策略

**要点和思考方向**
- 贪心算法简单高效，但需要证明正确性
- 注意贪心策略的选择
- 不一定得到全局最优，需要验证
- 适合需要快速近似解的场景

## 线性规划

**是什么？在哪用？**
- **作用**：在满足一组线性约束条件下，优化一个线性目标函数
- **应用场景**：
  - 资源分配问题
  - 生产计划
  - 运输问题
  - 需要数学优化的场景
- **应用**：资源分配、生产计划、运输问题等

**会遇到哪些问题？用什么解决？**
- **问题建模复杂**
  - **问题**：将实际问题转化为线性规划模型可能复杂
  - **解决方向**：
    - 简化问题模型
    - 使用线性规划工具
    - 参考类似问题的建模

- **计算复杂度**
  - **问题**：大规模线性规划问题计算可能很慢
  - **解决方向**：
    - 使用高效的线性规划求解器
    - 简化约束条件
    - 使用近似算法

**要点和思考方向**
- 线性规划适合数学优化问题
- 注意问题建模，准确表达约束和目标
- 使用成熟的求解器，避免自己实现
- 适合资源分配和优化问题

## 更多资料

## 在线资料
* [Flood Fill Algorithm in GameMaker: Studio (RECURSIVE APPROACH)](https://www.zackbanack.com/blog/floodfill)

## 视频资料
* [Algorithms and Data Structures Tutorial - Full Course for Beginners](https://www.youtube.com/watch?v=8hly31xKli0)
* [Game Development Tutorial | Lazy Flood Fill and Procedural Map Generation](https://www.youtube.com/watch?v=YS0MTrjxGbM)

## 电子文档
* [DATA STRUCTURES AND ALGORITHMS FOR GAME DEVELOPERS](https://doc.lagout.org/science/0_Computer%20Science/2_Algorithms/Data%20Structures%20and%20Algorithms%20for%20Game%20Developers.pdf)

## 题库
* [力扣](https://leetcode.cn/) - 一个在线的算法题库。