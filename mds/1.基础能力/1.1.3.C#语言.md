<h2 align="center">C#语言</h2>
<p>
C#是一个便捷、高效的编程语言，在前端开发中应用的较多，开发各类GUI工具也很好用。
</p>

**关键词:**<br/>
*C#,lambda表达式,泛型,dotnet,mono,IL2CPP,Unity,委托,事件,反射,GC,垃圾回收,协程,装箱拆箱,异步编程,Async,Await,UniTask,虚方法,抽象方法,Visual Studio*

**标签:**<br/>
*等级: 初级|中级, 阶段: 学习|开发, 分类: 基础能力, 角色: 客户端开发*

----
## 目录

- [目录](#目录)
- [使用场景](#使用场景)
- [类](#类)
- [虚方法](#虚方法)
- [抽象方法](#抽象方法)
- [委托](#委托)
- [事件](#事件)
- [反射](#反射)
- [垃圾回收（GC）](#垃圾回收gc)
- [协程](#协程)
- [装箱拆箱](#装箱拆箱)
- [异步编程](#异步编程)
- [泛型和系统类](#泛型和系统类)
- [异常](#异常)
- [中间件](#中间件)
  - [UniTask](#unitask)
  - [.Net](#net)
- [IDE](#ide)
  - [Visual Studio](#visual-studio)
  - [Visual Studio Code](#visual-studio-code)
  - [Rider](#rider)
- [更多资料](#更多资料)
  - [在线教程](#在线教程)
  - [文章资料](#文章资料)

----

## 使用场景

**是什么？在哪用？**
- **Unity脚本**：Unity引擎的主要脚本语言之一
- **工具开发**：无论是开发命令行工具，还是图形界面工具，C#（dotnet框架）都提供了一个非常高效的开发环境
- **业务层功能开发**：比如在AWS的Lambda服务中开发功能

## 类

**是什么？在哪用？**
- **作用**：类是面向对象编程的基本单元，用于封装数据和行为
- **应用场景**：所有面向对象的C#程序
- **特性**：
  - 封装：将数据和方法封装在一起
  - 继承：支持类之间的继承关系
  - 多态：支持虚方法和抽象方法实现多态

**会遇到哪些问题？用什么解决？**
- **封闭类（sealed）的扩展问题**
  - **问题**：通常封闭类的意图是要让这个类停止拓展了，但有的应用场景却需要拓展一个类。这时候就需要使用一些特定的方法来实现
  - **解决方向**：
    - 使用接口注入的方法
    - 通过扩展方法（Extension Methods）和静态字典来实现对封闭类的功能扩展
    - 使用组合而非继承
    - 使用装饰器模式

- **类设计不当**
  - **问题**：类设计不当，导致代码难以维护和扩展
  - **解决方向**：
    - 遵循单一职责原则
    - 合理使用继承和组合
    - 使用接口定义契约
    - 避免过深的继承层次

**要点和思考方向**
- 合理设计类的结构和关系
- 使用sealed关键字防止不必要的继承
- 使用扩展方法扩展封闭类的功能
- 遵循面向对象设计原则

## 虚方法

**是什么？在哪用？**
- **作用**：实现多态，允许子类重写父类的方法
- **应用场景**：需要子类提供不同实现但保持相同接口的场景
- **关键字**：
  - **virtual**：当你有意图让一个方法能在子类中有不同的实现，可以让这个方法定义为virtual
  - **override**：当你想重写父类的虚方法，可以在子类使用override
  - **base**：当你想一个子类的重写方法内也要做一下父类的虚方法的工作，可以使用base来调用父类的虚方法

**会遇到哪些问题？用什么解决？**
- **性能开销**
  - **问题**：虚方法调用有性能开销（虚函数表查找）
  - **解决方向**：
    - 在性能关键路径上减少虚方法调用
    - 使用sealed关键字标记不需要重写的方法
    - 考虑使用接口替代虚方法（如果适用）

- **设计不当**
  - **问题**：过度使用虚方法，导致设计复杂
  - **解决方向**：
    - 只在需要多态的地方使用虚方法
    - 使用接口定义契约
    - 考虑使用组合替代继承

**要点和思考方向**
- 虚方法提供更好的复用和扩展
- 理解virtual、override、base的使用
- 注意虚方法的性能开销
- 合理使用虚方法，避免过度设计

## 抽象方法

**是什么？在哪用？**
- **作用**：定义方法签名，强制子类实现，实现接口契约
- **应用场景**：当你希望一个类有一些行为，但这个行为需要各个子类自己进行定义的时候，可以使用abstract
- **特点**：
  - **abstract**：跟virtual的不同是abstract不提供实现
  - 包含抽象方法的类必须是抽象类
  - 子类必须实现所有抽象方法

**会遇到哪些问题？用什么解决？**
- **设计过度抽象**
  - **问题**：过度使用抽象方法，导致设计复杂
  - **解决方向**：
    - 只在真正需要强制实现的地方使用抽象方法
    - 考虑使用接口替代抽象类
    - 平衡抽象和具体实现

- **抽象类实例化**
  - **问题**：尝试实例化抽象类，导致编译错误
  - **解决方向**：
    - 理解抽象类不能直接实例化
    - 必须通过子类实例化
    - 使用接口或具体类替代（如果适用）

**要点和思考方向**
- 抽象方法强制子类实现，提供接口契约
- 抽象类不能直接实例化
- 合理使用抽象方法，避免过度抽象
- 考虑使用接口替代抽象类（如果适用）

## 委托

**是什么？在哪用？**
- **作用**：委托是一个类，它可以定义一个或多个函数指针，可以将一个函数指针赋值给委托变量，然后通过调用委托来调用委托变量所指向的函数
- **应用场景**：
  - 实现回调函数
  - 作为参数传递给其他函数使用
  - 事件处理
  - 策略模式实现

**会遇到哪些问题？用什么解决？**
- **委托为空**
  - **问题**：调用空委托导致NullReferenceException
  - **解决方向**：
    - 在调用前检查委托是否为空
    - 使用 `?.Invoke()` 安全调用
    - 使用 `??` 运算符提供默认值

- **内存泄漏**
  - **问题**：委托持有对象引用，导致对象无法被GC回收
  - **解决方向**：
    - 及时取消事件订阅（`-=`）
    - 使用弱事件模式（WeakEvent）
    - 避免在委托中持有大对象的引用

- **多播委托异常处理**
  - **问题**：多播委托中某个方法抛出异常，会影响后续方法的执行
  - **解决方向**：
    - 在委托方法内部处理异常
    - 手动遍历委托列表，单独处理每个委托
    - 使用 `GetInvocationList()` 获取委托列表

**要点和思考方向**
- 委托提供类型安全的函数指针
- 注意委托为空的情况，使用安全调用
- 及时取消事件订阅，避免内存泄漏
- 理解多播委托的执行机制

## 事件

**是什么？在哪用？**
- **作用**：事件是一种特殊的委托，它是用于向其他对象或组件发送通知的机制
- **应用场景**：
  - 实现消息传递机制，让不同的对象之间进行通信
  - UI事件处理（如按钮点击）
  - 观察者模式实现
  - 解耦对象之间的依赖关系
- **特点**：
  - 事件是一种多播委托，它可以让多个委托关联在一起
  - 当事件触发时，所有关联的委托都会被依次调用
  - 事件只能在定义它的类内部触发

**会遇到哪些问题？用什么解决？**
- **内存泄漏**
  - **问题**：事件订阅者未取消订阅，导致对象无法被GC回收
  - **解决方向**：
    - 及时取消事件订阅（`-=`）
    - 在对象销毁时取消所有事件订阅
    - 使用弱事件模式（WeakEvent）
    - 使用IDisposable模式管理事件订阅

- **事件触发顺序**
  - **问题**：多播委托的执行顺序不确定，可能导致问题
  - **解决方向**：
    - 不要依赖事件的执行顺序
    - 如果需要顺序，使用列表或队列管理订阅者
    - 使用 `GetInvocationList()` 控制执行顺序

- **事件异常处理**
  - **问题**：事件处理中抛出异常，会影响其他订阅者
  - **解决方向**：
    - 在事件处理内部捕获异常
    - 手动遍历事件列表，单独处理每个订阅者
    - 提供异常处理机制

**要点和思考方向**
- 事件提供解耦的对象间通信机制
- 及时取消事件订阅，避免内存泄漏
- 不要依赖事件的执行顺序
- 在事件处理中妥善处理异常

## 反射

**是什么？在哪用？**
- **作用**：运行时"自外而内"的对对象进行操作，获取和操作类型信息
- **应用场景**：
  - 动态加载类型、调用方法、访问属性等需要运行时类型信息的场景
  - 序列化和反序列化
  - 依赖注入框架
  - 插件系统
  - 代码生成和元编程

**会遇到哪些问题？用什么解决？**
- **性能问题**
  - **问题**：反射操作有较大的性能开销，比直接调用慢很多
  - **解决方向**：
    - 缓存反射结果（如MethodInfo、PropertyInfo）
    - 使用表达式树（Expression Trees）替代反射
    - 使用委托缓存方法调用
    - 在性能关键路径上避免使用反射

- **类型安全问题**
  - **问题**：反射绕过了编译时类型检查，可能导致运行时错误
  - **解决方向**：
    - 使用泛型约束
    - 添加类型检查
    - 使用强类型API替代反射（如果可能）

- **代码可读性**
  - **问题**：反射代码可读性差，难以维护
  - **解决方向**：
    - 封装反射操作为辅助方法
    - 添加详细的注释
    - 使用代码生成工具替代反射

**要点和思考方向**
- 反射提供强大的运行时类型操作能力
- 注意反射的性能开销，合理使用
- 缓存反射结果，提高性能
- 考虑使用替代方案（如表达式树、代码生成）

## 垃圾回收（GC）

**是什么？在哪用？**
- **作用**：自动管理内存，自动回收不再使用的对象
- **应用场景**：所有C#程序，自动运行，无需手动管理
- **特点**：
  - 自动管理内存生命周期
  - 分代回收（Generation 0, 1, 2）
  - 非确定性回收时机

**会遇到哪些问题？用什么解决？**
- **GC暂停（Stop-the-World）**
  - **问题**：GC回收时会暂停程序执行，导致卡顿
  - **解决方向**：
    - 减少对象分配，降低GC频率
    - 使用对象池复用对象
    - 避免大对象分配（>85KB进入大对象堆）
    - 使用结构体（值类型）减少堆分配

- **内存泄漏**
  - **问题**：对象持有引用导致无法被GC回收
  - **解决方向**：
    - 避免循环引用
    - 及时取消事件订阅
    - 使用弱引用（WeakReference）
    - 使用IDisposable模式释放资源

- **性能优化**
  - **问题**：频繁的GC影响性能
  - **解决方向**：
    - **避免大对象分配**：减少GC压力
    - **预设定好容器大小**：减少运行时的不断扩展，避免频繁的内存重新分配
    - **ArrayPool**：使用对象池复用数组，减少分配
    - **使用结构**：值类型在栈上分配，减少堆分配
    - **StringBuilder**：字符串拼接时使用StringBuilder而不是直接拼接
    - **慎用GC.Collect**：手动触发GC可能影响性能
    - **慎用Finalize**：Finalize方法会影响GC性能

**要点和思考方向**
- GC自动管理内存，但要注意性能影响
- 减少对象分配，降低GC频率
- 使用对象池复用对象
- 避免内存泄漏，及时释放资源
- 在性能关键路径上优化GC压力

## 协程

**是什么？在哪用？**
- **作用**：协程是一种特殊的迭代器，可以使得程序在执行过程中能够暂停、等待一段时间后再继续执行
- **应用场景**：
  - Unity中常用于实现延迟执行、分帧处理等异步逻辑
  - 实现状态机
  - 实现动画序列
  - 实现分帧加载

**会遇到哪些问题？用什么解决？**
- **协程生命周期管理**
  - **问题**：协程的生命周期管理复杂，容易导致协程无法停止
  - **解决方向**：
    - 保存协程引用，便于停止
    - 在对象销毁时停止所有协程
    - 使用协程管理器统一管理
    - 检查协程是否还在运行

- **性能问题**
  - **问题**：大量协程可能影响性能
  - **解决方向**：
    - 限制同时运行的协程数量
    - 合并相似的协程
    - 使用对象池管理协程
    - 在性能关键路径上考虑使用其他方案

- **异常处理**
  - **问题**：协程中的异常难以捕获和处理
  - **解决方向**：
    - 在协程内部使用try-catch
    - 使用协程包装器处理异常
    - 提供异常回调机制

**要点和思考方向**
- 协程提供灵活的异步执行机制
- 注意协程的生命周期管理
- 在Unity中，协程在主线程执行
- 合理使用协程，避免性能问题

## 装箱拆箱

**是什么？在哪用？**
- **作用**：值类型和引用类型之间的转换
- **应用场景**：
  - 想让一个方法的参数不预定为某个具体的数值类型
  - 想做一个容器，包含的非特定类型的数值
  - 与object类型交互时
- **说明**：
  - **装箱**：将值类型转换成引用类型（值类型→object）
  - **拆箱**：将引用类型转换成值类型（object→值类型）

**会遇到哪些问题？用什么解决？**
- **性能问题**
  - **问题**：装箱和拆箱会带来性能开销，应尽量避免不必要的装箱拆箱操作
  - **解决方向**：
    - 使用泛型替代object类型
    - 使用值类型的集合（如List<int>而非List<object>）
    - 避免在循环中进行装箱拆箱
    - 使用接口约束（如IComparable<T>）而非object

- **类型安全问题**
  - **问题**：拆箱时类型不匹配会导致InvalidCastException
  - **解决方向**：
    - 使用is或as运算符进行类型检查
    - 使用泛型避免拆箱
    - 确保拆箱类型匹配

**要点和思考方向**
- 装箱拆箱有性能开销，应尽量避免
- 使用泛型替代object类型，避免装箱拆箱
- 注意拆箱时的类型安全
- 在性能关键路径上避免装箱拆箱

## 异步编程

**是什么？在哪用？**
- **作用**：C#的异步编程模型，用于处理异步操作，避免阻塞主线程
- **应用场景**：
  - 有IO操作的地方
  - **举例**：
    - 网络请求
    - 文件操作
    - 数据库查询
    - Web API调用
- **关键字**：
  - **Async/Await**：C#的异步编程模型，用于处理异步操作

**会遇到哪些问题？用什么解决？**
- **死锁风险**
  - **问题**：不当使用async/await可能导致死锁
  - **解决方向**：
    - 避免在同步上下文中使用 `.Result` 或 `.Wait()`
    - 使用 `ConfigureAwait(false)` 避免捕获同步上下文
    - 保持异步调用链，避免混合同步和异步
    - 使用 `Task.Run` 在后台线程执行

- **性能考虑**
  - **问题**：在Unity中，async/await与协程的性能对比需要根据具体场景选择
  - **解决方向**：
    - 在Unity中，协程通常性能更好（主线程执行）
    - async/await适合IO操作（网络、文件）
    - 使用UniTask在Unity中获得更好的性能
    - 避免在热路径上使用async/await

- **异常处理**
  - **问题**：异步方法中的异常处理复杂
  - **解决方向**：
    - 使用try-catch捕获异步方法中的异常
    - 注意异常在await处抛出
    - 使用 `Task.Exception` 处理任务异常
    - 提供全局异常处理

- **取消操作**
  - **问题**：长时间运行的异步操作需要支持取消
  - **解决方向**：
    - 使用 `CancellationToken` 支持取消
    - 在异步方法中检查取消标记
    - 使用 `CancellationTokenSource` 管理取消

**要点和思考方向**
- async/await提供优雅的异步编程模型
- 避免死锁，正确使用async/await
- 在Unity中，根据场景选择协程或async/await
- 妥善处理异步异常
- 支持异步操作的取消

## 泛型和系统类

**是什么？在哪用？**
- **作用**：提供类型参数化，实现代码复用和类型安全
- **应用场景**：
  - 集合类（List<T>、Dictionary<TKey, TValue>等）
  - 方法参数和返回值
  - 接口和委托
- **系统类**：.NET框架提供的丰富类库，包括集合、IO、网络、字符串处理等

**会遇到哪些问题？用什么解决？**
- **类型约束**
  - **问题**：泛型类型约束使用不当，导致编译错误
  - **解决方向**：
    - 理解泛型约束（where T : class, new()等）
    - 合理使用约束，避免过度约束
    - 使用接口约束而非具体类约束

- **性能问题**
  - **问题**：泛型代码可能影响性能（JIT编译）
  - **解决方向**：
    - 理解泛型的性能特征
    - 避免不必要的泛型嵌套
    - 使用值类型泛型参数（如果适用）

**要点和思考方向**
- 泛型提供类型安全的代码复用
- 使用泛型避免装箱拆箱
- 理解泛型约束的使用
- 利用.NET框架提供的丰富类库

## 异常

**是什么？在哪用？**
- **作用**：用于捕获和处理程序运行时的错误
- **应用场景**：
  - 处理运行时错误
  - 资源清理（using语句）
  - 错误恢复
  - 日志记录

**会遇到哪些问题？用什么解决？**
- **过度捕获异常**
  - **问题**：捕获所有异常（catch(Exception)），隐藏真正的错误
  - **解决方向**：
    - 只捕获能处理的异常
    - 使用具体的异常类型
    - 让无法处理的异常向上传播
    - 在顶层提供全局异常处理

- **性能问题**
  - **问题**：异常处理有性能开销，不应用于正常流程控制
  - **解决方向**：
    - 异常用于异常情况，不用于正常流程
    - 使用返回值或out参数处理正常情况
    - 避免在循环中使用异常处理

- **资源泄漏**
  - **问题**：异常导致资源未释放
  - **解决方向**：
    - 使用using语句自动释放资源
    - 使用try-finally确保资源释放
    - 实现IDisposable模式

**要点和思考方向**
- 合理使用try-catch，避免过度捕获异常
- 异常用于异常情况，不用于正常流程控制
- 使用using语句确保资源释放
- 提供详细的异常信息，便于调试

## 中间件

**是什么？在哪用？**
- **作用**：提供额外的功能和工具，简化开发
- **应用场景**：Unity开发、性能优化、代码简化

### UniTask

**是什么？在哪用？**
- **作用**：提供了一个异步流程控制的库
- **应用场景**：Unity中的高性能异步编程，比传统Task性能更好
- **优势**：
  - 零GC分配
  - 更好的Unity集成
  - 支持Unity的协程和async/await混合使用

**会遇到哪些问题？用什么解决？**
- **学习成本**
  - **问题**：需要学习UniTask的API和使用方式
  - **解决方向**：
    - 阅读UniTask文档和示例
    - 逐步迁移现有代码
    - 理解UniTask与Task的区别

**要点和思考方向**
- UniTask在Unity中提供更好的异步编程性能
- 适合Unity游戏开发中的异步操作
- 注意与标准Task的API差异

### .Net

**是什么？在哪用？**
- **作用**：.NET框架提供跨平台的运行时和开发环境
- **应用场景**：Unity游戏开发、跨平台应用开发
- **运行时**：
  - **IL2CPP**：将IL代码转换为C++代码，提高性能
  - **AOT编译器**：提前编译，提高运行时性能
  - **Mono编译器**：跨平台的.NET运行时

**会遇到哪些问题？用什么解决？**
- **平台兼容性**
  - **问题**：不同编译器的行为可能略有差异
  - **解决方向**：
    - 在不同平台上测试代码
    - 注意平台特定的API差异
    - 使用条件编译处理平台差异

- **性能差异**
  - **问题**：IL2CPP通常性能更好，但编译时间更长
  - **解决方向**：
    - 开发时使用Mono，发布时使用IL2CPP
    - 优化编译时间（增量编译）
    - 根据项目需求选择合适的运行时

- **IL2CPP限制**
  - **问题**：IL2CPP不支持某些.NET特性（如反射的部分功能）
  - **解决方向**：
    - 了解IL2CPP的限制
    - 避免使用不支持的特性
    - 使用代码生成替代反射

**要点和思考方向**
- 理解不同.NET运行时的特点和限制
- IL2CPP提供更好的性能，但编译时间更长
- 注意平台兼容性和API差异
- 在Unity中，根据需求选择合适的运行时

## IDE

**是什么？在哪用？**
- **作用**：提供代码编辑、调试、编译等开发工具
- **应用场景**：所有C#开发

### Visual Studio

**是什么？在哪用？**
- **说明**：微软官方IDE，功能强大
- **特点**：
  - 强大的代码补全和智能提示
  - 集成调试器
  - 丰富的插件生态
  - 支持多种项目类型

### Visual Studio Code

**是什么？在哪用？**
- **说明**：轻量级代码编辑器
- **特点**：
  - 跨平台
  - 丰富的扩展
  - 适合轻量级开发

### Rider

**是什么？在哪用？**
- **说明**：JetBrains的C# IDE
- **特点**：
  - 强大的重构工具
  - 优秀的代码分析
  - 跨平台支持

**要点和思考方向**
- 根据项目需求选择合适的IDE
- Visual Studio适合Windows开发
- Visual Studio Code适合轻量级开发
- Rider提供强大的代码分析工具

## 更多资料

### 在线教程
* [C# Tutorial](https://tutorial.techaltum.com/C-Sharp.html) - 在线C#教程。
* [C# Design Patterns](https://www.dofactory.com/net/design-patterns) - C#设计模式的实现。

### 文章资料
* [Performance in Unity: async, await, and Tasks vs. coroutines, C# Job System, and burst compiler](https://blog.logrocket.com/performance-unity-async-await-tasks-coroutines-c-job-system-burst-compiler/) - 本文介绍什么是 C# 中的 async、await 和 Task，以及如何在 Unity 中使用它们来提高项目性能。
* [C# Virtual](https://linuxhint.com/virtual-csharp/) - 关于C#的虚函数。