<h2 align="center">计算机组成原理</h2>
<p>
了解了计算机组成原理，在调试一些数据或者指令的问题时，就会有更明确的方向。
</p>

**关键词:**<br/>
*计算机组成原理,CPU,Memory,内存,Endianness,字节序,Big endianness,Little endianness,SIMD,单指令多数据流,MIPS,X86,ARM,指令集,缓存,Cache,多核,定点数,浮点数,二进制,八进制,十进制,十六进制,数位,RAM,ROM*

**标签:**<br/>
*等级: 高级, 阶段: 学习|优化, 分类: 基础能力, 角色: 客户端开发|服务端开发*

----
## 作用

### 是什么？在哪用？

- **作用**：理解计算机组成原理有助于深度优化系统，提高系统运行效率
- **应用场景**：
  - 性能优化
  - 内存优化
  - 指令级优化
  - 跨平台开发
  - 调试底层问题

### 要点和思考方向

- 理解计算机组成原理有助于进行深度优化
- 在游戏开发中，了解CPU、内存、缓存等硬件特性有助于优化性能
- 不同平台（PC、移动、主机）的硬件特性不同，需要针对性优化

## 架构

### 是什么？在哪用？

- **作用**：不同的CPU架构有不同的指令集和特性
- **应用场景**：
  - 跨平台游戏开发
  - 性能优化
  - 平台特定优化
- **类型**：
- **MIPS**
  - **指令集**：MIPS架构的指令集
    - **应用**：某些嵌入式设备和游戏主机（如PS2）

- **X86**
  - **应用**：PC平台的主要架构
    - **特点**：复杂指令集（CISC），性能强大

- **ARM**
  - **应用**：移动平台和嵌入式设备的主要架构
    - **特点**：精简指令集（RISC），功耗低

### 会遇到哪些问题？用什么解决？

- **跨平台兼容性**
  - **问题**：不同架构的指令集不同，代码可能不兼容
  - **解决方向**：
    - 使用高级语言（编译器处理）
    - 使用跨平台库
    - 条件编译处理平台差异
    - 使用虚拟机或解释器

- **性能差异**
  - **问题**：不同架构的性能特性不同
  - **解决方向**：
    - 针对不同架构优化
    - 使用架构特定的优化（如SIMD）
    - 性能测试和调优

### 要点和思考方向

- 不同架构有不同的指令集和性能特性
- 跨平台开发要考虑架构差异
- 深度优化需要了解目标架构的特性

## CPU

### 是什么？在哪用？

- **作用**：中央处理器，执行指令和处理数据
- **应用场景**：
  - 程序执行
  - 性能优化
  - 游戏逻辑处理

### 指令集

### 是什么？在哪用？

- **作用**：CPU支持的指令集合
- **应用场景**：
  - 性能优化
  - 向量运算
  - 并行计算
- **SIMD（Single Instruction Multiple Data）**
  - **说明**：单指令多数据流，一条指令可以同时处理多个数据
  - **应用**：向量运算、图像处理等需要并行计算的场景
  - **实现**：SSE（X86）、NEON（ARM）、AVX等

### 会遇到哪些问题？用什么解决？

- **SIMD使用复杂**
  - **问题**：直接使用SIMD指令比较复杂
  - **解决方向**：
    - 使用编译器自动向量化
    - 使用SIMD库（如Intel MKL）
    - 使用游戏引擎提供的SIMD接口
    - 使用内联函数封装

- **平台兼容性**
  - **问题**：不同平台的SIMD指令不同
  - **解决方向**：
    - 使用跨平台SIMD库
    - 条件编译处理平台差异
    - 运行时检测CPU特性

### 要点和思考方向

- SIMD可以显著提高向量运算性能
- 游戏开发中常用于物理计算、动画、粒子系统等
- 使用编译器自动向量化或SIMD库简化开发
- 注意平台兼容性

### 缓存（Cache）

### 是什么？在哪用？

- **作用**：CPU的高速缓存，用于存储频繁访问的数据和指令
- **应用场景**：
  - 性能优化
  - 内存访问优化
- **层级**：L1、L2、L3缓存，速度递减，容量递增

### 会遇到哪些问题？用什么解决？

- **缓存未命中**
  - **问题**：缓存未命中导致性能下降
  - **解决方向**：
    - 优化数据布局（提高局部性）
    - 使用连续内存（数组而非链表）
    - 预取数据
    - 减少随机访问
    - 使用SoA（Structure of Arrays）而非AoS（Array of Structures）

- **缓存一致性**
  - **问题**：多核环境下缓存一致性问题
  - **解决方向**：
    - 避免false sharing（伪共享）
    - 使用线程局部存储
    - 合理设计数据结构

### 要点和思考方向

- 缓存命中率对性能影响很大
- 优化数据布局和访问模式可以提高缓存命中率
- 游戏开发中要注意内存访问模式
- 使用性能分析工具检测缓存问题

### 多核

### 是什么？在哪用？

- **作用**：多个CPU核心可以并行处理任务
- **应用场景**：
  - 多线程编程
  - 并行计算
  - 任务分离（渲染、网络、音频等）

### 会遇到哪些问题？用什么解决？

- **负载均衡**
  - **问题**：任务分配不均导致部分核心空闲
  - **解决方向**：
    - 使用任务队列
    - 使用工作窃取算法
    - 合理分配任务
    - 使用线程池

- **同步开销**
  - **问题**：多核之间的同步可能带来开销
  - **解决方向**：
    - 减少共享数据
    - 使用无锁数据结构
    - 使用线程局部存储
    - 避免过度同步

### 要点和思考方向

- 多核可以显著提高性能，但需要合理利用
- 游戏开发中通常将不同系统分配到不同线程
- 注意同步开销，避免过度使用锁
- 使用性能分析工具检测负载均衡

### 在游戏开发中的考虑

### 是什么？在哪用？

- **作用**：进行游戏深度优化时，就要考虑指令、缓存的使用
- **应用场景**：
  - 性能关键路径优化
  - 物理计算优化
  - 渲染优化
  - 内存访问优化

### 要点和思考方向

- 游戏开发中要充分利用CPU特性（SIMD、多核、缓存）
- 优化数据布局和访问模式
- 使用性能分析工具定位瓶颈
- 平衡优化成本和收益

### Endianness（字节序）

### 是什么？在哪用？

- **作用**：理解数据在内存中的存储顺序
- **应用场景**：
  - 跨平台数据传输
  - 网络通信
  - 文件格式解析
  - 位操作
- **说明**：不同的CPU/GPU，字节的数据（前后）顺序会不同
- **类型**：
  - **Big endianness（大端序）**
    - **应用**：在游戏领域，主要是XBox会用这种
    - **特点**：高位字节在前
  - **Little endianness（小端序）**
    - **应用**：大多数平台使用小端序（PC、移动平台等）
    - **特点**：低位字节在前

### 会遇到哪些问题？用什么解决？

- **字节序问题**
  - **问题**：不同平台的数据字节序不同，可能导致数据解析错误
  - **应用场景**：比如要对加载到内存中的数据进行bit操作，就要考虑其顺序
  - **解决方向**：
    - 进行字节序转换
    - 使用网络字节序（大端序）进行数据传输
    - 使用标准库函数（如`htonl`、`ntohl`）
    - 使用序列化库处理字节序

- **数据解析错误**
  - **问题**：字节序错误导致数据解析错误
  - **解决方向**：
    - 明确数据格式的字节序
    - 使用字节序转换函数
    - 测试不同平台
    - 使用标准化的数据格式

### 要点和思考方向

- 字节序问题主要在跨平台开发中出现
- 网络通信通常使用大端序（网络字节序）
- 文件格式要明确字节序
- 使用标准库函数处理字节序转换

## 数据表示方式

### 定点数

### 是什么？在哪用？

- **作用**：使用固定小数点的数值表示方式，性能比浮点数高
- **应用场景**：
  - 跨平台数据一致性
  - 低配置平台优化
  - 需要确定精度的场景
- **类型**：
- **定点小数**
  - **有符号数**：约定小数点在符号位的后面
  - **无符号数**：约定小数点在最前边

- **定点整数**：约定小数点在最后边

### 会遇到哪些问题？用什么解决？

- **溢出**
  - **问题**：定点数运算可能溢出
  - **解决方向**：
    - 注意数值范围
    - 使用更大的数据类型
    - 检查溢出
    - 使用饱和运算（saturating arithmetic）

- **精度限制**
  - **问题**：定点数的精度是固定的，可能不够用
  - **解决方向**：
    - 选择合适的定点数格式
    - 使用更高精度的定点数
    - 在关键位置使用浮点数

- **实现复杂**
  - **问题**：定点数运算需要手动处理小数位
  - **解决方向**：
    - 使用定点数库
    - 封装定点数运算函数
    - 使用宏或内联函数简化代码

### 优点

- **性能更高**：定点数运算比浮点数运算更快
- **精度确定**：精度是固定的，不会因平台而异
- **跨平台一致**：不同平台的运算结果一致

### 应用举例

- **跨平台数据一致性**：不同设备（比如手机、电脑、游戏机）的浮点精度不同，在不同设备上同步数据要保证一致性，就可以考虑使用定点数

- **低配置平台优化**：有些平台（比如某些掌上游戏机）的配置相对较低，所以需要尽量的用更优化的方式开发，就会采用定点数

### 要点和思考方向

- 定点数适合需要确定精度和跨平台一致性的场景
- 性能比浮点数高，但实现相对复杂
- 注意溢出和精度限制
- 游戏开发中常用于物理计算、位置同步等

### 浮点数

### 是什么？在哪用？

- **作用**：使用科学计数法表示实数，使用灵活
- **应用场景**：
  - 常规数值计算
  - 物理计算
  - 图形计算
  - 需要表示很大或很小数值的场景
- **类型**：
  - **单精度（float）**：32位，精度约7位小数
  - **双精度（double）**：64位，精度约15位小数

### 会遇到哪些问题？用什么解决？

- **精度丢失**
  - **问题**：浮点数运算可能产生精度误差
  - **解决方向**：
    - 使用更高精度的浮点数类型（double）
    - 使用定点数（如果需要确定精度）
    - 避免累积误差
    - 使用误差容忍比较（如`abs(a - b) < epsilon`）

- **跨平台精度差异**
  - **问题**：不同平台的浮点精度可能不同
  - **解决方向**：
    - 使用定点数（如果需要跨平台一致性）
    - 明确浮点精度要求
    - 测试不同平台
    - 使用标准化的浮点格式

- **性能问题**
  - **问题**：浮点运算可能比定点数慢
  - **解决方向**：
    - 使用定点数（如果适用）
    - 优化浮点运算（如使用SIMD）
    - 减少浮点运算次数
    - 使用快速数学函数（如快速sqrt）

### 优点

- **使用更灵活**：可以表示很大或很小的数值
- **精度足够**：对于大多数应用，精度足够
- **实现简单**：直接使用，无需手动处理

### 要点和思考方向

- 浮点数适合大多数数值计算场景
- 注意精度丢失和跨平台精度差异
- 游戏开发中通常使用float（单精度）以节省内存
- 在关键位置（如物理计算）可以使用double（双精度）

## 进制

### 是什么？在哪用？

- **作用**：不同的数值表示方式，适用于不同场景
- **应用场景**：
  - 数值计算
  - 位操作
  - 数据存储
  - 调试和分析

### 二进制

### 是什么？在哪用？

- **作用**：计算机内部使用的数值表示方式
- **应用场景**：
  - 位运算
  - 数据存储
  - 性能优化
- **应用举例**：
  - **位运算**：使用位运算进行高效操作
  - **分析数值的越界问题**：通过二进制表示分析数值范围
  - **地图/图片数据的存储与操作**：使用位图存储和操作数据

### 会遇到哪些问题？用什么解决？

- **可读性差**
  - **问题**：二进制表示可读性差
  - **解决方向**：
    - 使用十六进制表示
    - 使用注释说明
    - 使用常量定义

### 要点和思考方向

- 二进制是计算机的基础
- 理解二进制有助于理解位运算和内存布局
- 使用位运算可以提高性能

### 八进制

### 是什么？在哪用？

- **作用**：某些场景下使用的数值表示方式
- **应用场景**：
  - 系统权限设置
  - Unix文件权限
- **应用**：某些系统权限设置等场景

### 要点和思考方向

- 八进制使用较少，主要在Unix系统权限中使用
- 理解八进制有助于理解Unix文件权限

### 十进制

### 是什么？在哪用？

- **作用**：人类常用的数值表示方式
- **应用场景**：
  - 常规的运算
  - 用户界面显示
  - 数值计算
- **应用**：常规的运算

### 要点和思考方向

- 十进制是人类最常用的数值表示方式
- 程序内部通常使用二进制，显示时转换为十进制

### 十六进制

### 是什么？在哪用？

- **作用**：便于表示二进制数据的数值表示方式
- **应用场景**：
  - 颜色值表示
  - 内存地址表示
  - 调试和分析
- **应用举例**：
  - **颜色数值的定义**：RGB颜色值常用十六进制表示（如 #FF0000 表示红色）
  - **内存地址**：调试时常用十六进制表示内存地址
  - **数据转储**：二进制数据常用十六进制显示

### 要点和思考方向

- 十六进制便于表示二进制数据
- 一个十六进制位对应4个二进制位
- 游戏开发中常用于颜色值、内存地址等

## 数位

### 是什么？在哪用？

- **作用**：数据在内存中的位数表示，决定数据的表示范围和精度
- **应用场景**：
  - 数据类型选择
  - 内存优化
  - 数值范围控制
- **常见类型**：
  - **8位**：char、byte，范围-128到127或0到255
  - **16位**：short，范围-32768到32767
  - **32位**：int、float，范围约±21亿或±3.4×10³⁸
  - **64位**：long、double，范围更大

### 会遇到哪些问题？用什么解决？

- **溢出**
  - **问题**：数值超出数据类型的表示范围
  - **解决方向**：
    - 使用更大的数据类型
    - 检查溢出
    - 使用无符号类型（如果适用）
    - 使用饱和运算

- **内存浪费**
  - **问题**：使用过大的数据类型浪费内存
  - **解决方向**：
    - 根据实际需求选择数据类型
    - 使用合适的数据类型
    - 在内存紧张时优化数据类型

- **精度不足**
  - **问题**：数据类型精度不足
  - **解决方向**：
    - 使用更高精度的数据类型
    - 使用定点数或浮点数
    - 重新设计数据结构

### 要点和思考方向

- 选择合适的数位可以平衡内存和性能
- 注意数值范围，避免溢出
- 游戏开发中要根据实际需求选择数据类型
- 移动平台要注意内存使用

## 内存

### 是什么？在哪用？

- **作用**：存储程序和数据
- **应用场景**：
  - 程序执行
  - 数据存储
  - 性能优化
- **类型**：
  - **RAM（随机存取存储器）**：易失性内存，用于运行时数据
  - **ROM（只读存储器）**：非易失性内存，用于存储固件等
- **考虑**：内存访问速度、容量、带宽等

### 会遇到哪些问题？用什么解决？

- **内存不足**
  - **问题**：内存容量不足导致程序无法运行
  - **解决方向**：
    - 优化内存使用
    - 使用内存池
    - 延迟加载
    - 释放不需要的内存

- **内存访问慢**
  - **问题**：内存访问速度慢影响性能
  - **解决方向**：
    - 使用缓存
    - 优化数据布局
    - 减少内存访问
    - 使用连续内存

- **内存碎片**
  - **问题**：频繁分配释放导致内存碎片
  - **解决方向**：
    - 使用内存池
    - 预分配内存
    - 使用对象池
    - 定期整理内存

### 要点和思考方向

- 内存是重要的系统资源，需要合理管理
- 内存访问速度对性能影响很大
- 游戏开发中要注意内存预算和优化
- 使用内存分析工具监控内存使用

## 更多资料

### 在线资料
* [big-endian and little-endian](https://www.techtarget.com/searchnetworking/definition/big-endian-and-little-endian#:~:text=Big%2Dendian%20is%20an%20order,the%20sequence\)%20is%20stored%20first.)
* [Difference Between Fixed Point and Floating Point](https://pediaa.com/difference-between-fixed-point-and-floating-point/) - 浮点数与定点数的差别。

### 视频资料
* [How do CPUs read machine code? — 6502 part 2](https://www.youtube.com/watch?v=yl8vPW5hydQ)
* [Floating Point Numbers (Part1: Fp vs Fixed) - Computerphile](https://www.youtube.com/watch?v=f4ekifyijIg)