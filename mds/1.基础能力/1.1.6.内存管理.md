<h2 align="center">内存管理</h2>
<p>
当开始考虑系统的运行效率、稳定性的时候，内存管理就是一个不得不认真去考虑的事情。
</p>

**关键词:**<br/>
*内存对齐,GC,内存池,静态内存,动态内存,局部变量*

**标签:**<br/>
*等级: 中级|高级, 阶段: 学习|开发|优化, 分类: 基础能力, 角色: 客户端开发|服务端开发*

----
## 目录

- [目录](#目录)
- [为什么要关注内存？](#为什么要关注内存)
- [问题](#问题)
- [内存池](#内存池)
- [内存使用效率](#内存使用效率)
- [局部变量](#局部变量)
  - [特点](#特点)
- [静态内存](#静态内存)
  - [特点](#特点-1)
- [生命期](#生命期)
  - [动态内存](#动态内存)
  - [特点](#特点-2)
  - [生命期](#生命期-1)
- [GC（垃圾回收）](#gc垃圾回收)
  - [算法](#算法)
  - [算法类型](#算法类型)
- [游戏开发中的应用](#游戏开发中的应用)
  - [内存规划](#内存规划)
    - [规划内容](#规划内容)
  - [方案选择](#方案选择)
    - [选择原则](#选择原则)
  - [实践建议](#实践建议)
- [更多资料](#更多资料)
  - [问答资料](#问答资料)

----

## 为什么要关注内存？

**是什么？在哪用？**
- **重要性**：内存是一个重要资源，合理的使用内存，可以让程序高效、稳定
- **应用场景**：所有需要高性能和稳定性的程序都需要关注内存管理

## 问题

**是什么？在哪用？**
- **作用**：了解内存管理中的常见问题，有助于提前预防和解决
- **应用场景**：所有需要高性能和稳定性的程序

**会遇到哪些问题？用什么解决？**
- **服务端程序内存泄漏**
  - **问题**：服务端程序的内存持续泄漏，最后让系统内存不足，分配不出来新的内存，服务端崩溃
  - **影响**：系统不稳定，服务中断
  - **解决方向**：
    - 使用内存分析工具（如Valgrind、AddressSanitizer）检测泄漏
    - 使用智能指针（C++）或RAII模式
    - 定期监控内存使用情况
    - 建立内存泄漏检测机制
    - 代码审查，确保成对分配和释放

- **客户端性能问题**
  - **问题**：客户端的loop中有大量的内存分配、释放，造成程序的FPS降低
  - **影响**：用户体验下降，游戏卡顿
  - **解决方向**：
    - 使用内存池预分配内存
    - 使用对象池复用对象
    - 避免在游戏循环中分配内存
    - 使用栈内存替代堆内存（如果适用）
    - 延迟分配，批量处理

- **内存碎片化**
  - **问题**：频繁分配释放导致内存碎片，影响分配效率和性能
  - **解决方向**：
    - 使用内存池减少碎片
    - 使用固定大小的内存块
    - 定期整理内存（如果支持）
    - 使用内存对齐减少碎片

- **内存溢出**
  - **问题**：程序申请的内存超过系统可用内存
  - **解决方向**：
    - 设置内存预算和限制
    - 检查内存分配是否成功
    - 使用流式处理大文件
    - 及时释放不需要的内存

**要点和思考方向**
- 内存泄漏会导致系统不稳定，需要建立检测机制
- 频繁的内存分配释放会影响性能，使用内存池和对象池
- 注意内存碎片化问题，合理设计内存分配策略
- 设置内存预算，防止内存溢出

## 内存池

**是什么？在哪用？**
- **作用**：预先分配一大块内存，然后从这块内存中分配小块内存，避免频繁的分配释放内存，产生碎片。影响内存使用效率，并且降低运行效率
  - **分配释放内存，效率低**：频繁的内存分配和释放操作本身就有性能开销
  - **访问不连续内存，效率低**：内存碎片导致访问不连续，影响CPU缓存效率
- **应用场景**：
  - 需要频繁分配释放内存的场景
  - 游戏中的对象池、粒子系统等
  - 网络数据包处理
  - 临时缓冲区管理

**会遇到哪些问题？用什么解决？**
- **内存池大小设计**
  - **问题**：内存池大小设置不当，可能导致内存浪费或频繁扩容
  - **解决方向**：
    - 根据实际使用情况统计内存需求
    - 设置合理的内存池初始大小
    - 支持动态扩容（如果必要）
    - 为不同大小的对象使用不同的内存池

- **内存池碎片**
  - **问题**：内存池内部也可能产生碎片
  - **解决方向**：
    - 使用固定大小的内存块
    - 定期整理内存池（如果支持）
    - 使用分级内存池（不同大小的块）

- **线程安全**
  - **问题**：多线程环境下，内存池需要保证线程安全
  - **解决方向**：
    - 使用锁保护内存池操作
    - 使用无锁数据结构（如果适用）
    - 为每个线程提供独立的内存池（Thread Local）

**要点和思考方向**
- 内存池可以显著提高内存分配效率，减少碎片
- 合理设计内存池大小，避免浪费或频繁扩容
- 注意线程安全问题，多线程环境下需要同步
- 根据对象大小使用不同的内存池策略

## 内存使用效率

**是什么？在哪用？**
- **作用**：优化内存访问模式，提高CPU访问内存的效率
- **应用场景**：所有性能关键路径
- **优化方向**：
  - **内存对齐**：按照CPU访问要求对齐内存，提高访问效率
  - **内存连续**：保持内存的连续性，提高缓存命中率

**会遇到哪些问题？用什么解决？**
- **内存对齐问题**
  - **问题**：未对齐的内存访问可能导致性能下降或错误
  - **解决方向**：
    - 使用编译器对齐指令（如 `__attribute__((aligned))`）
    - 理解目标平台的对齐要求
    - 在结构体中合理安排成员顺序
    - 使用对齐的内存分配函数

- **缓存未命中**
  - **问题**：不连续的内存访问导致缓存未命中，性能下降
  - **解决方向**：
    - 使用连续的内存布局（如数组而非链表）
    - 使用内存池保持内存连续
    - 优化数据结构布局（如SoA而非AoS）
    - 预取数据（如果适用）

- **内存浪费**
  - **问题**：内存对齐可能导致内存浪费
  - **解决方向**：
    - 在性能和内存之间权衡
    - 对于非性能关键路径，可以放宽对齐要求
    - 使用紧凑的数据结构（如果性能允许）

**要点和思考方向**
- 内存对齐和连续性对性能有重要影响
- 在性能关键路径上优化内存布局
- 理解CPU缓存机制，提高缓存命中率
- 在性能和内存使用之间找到平衡

## 局部变量

**是什么？在哪用？**
- **作用**：函数内部的临时变量，分配在栈上
- **应用场景**：
  - 函数内部的临时变量
  - 小对象和基本类型
  - 性能关键路径的临时数据

### 特点

- **分配位置**：分配在栈上
- **生命期**：函数调用时创建和销毁
- **优势**：分配和释放速度快，自动管理
- **限制**：栈空间有限，不适合大对象

**会遇到哪些问题？用什么解决？**
- **栈溢出**
  - **问题**：栈空间有限，大对象或深度递归可能导致栈溢出
  - **解决方向**：
    - 避免在栈上分配大对象
    - 限制递归深度
    - 使用堆内存分配大对象
    - 增加栈大小（如果可能）

- **性能考虑**
  - **问题**：栈内存访问速度快，但空间有限
  - **解决方向**：
    - 小对象和临时数据使用栈内存
    - 大对象使用堆内存
    - 在性能关键路径上优先使用栈内存

**要点和思考方向**
- 栈内存分配释放快，适合小对象和临时数据
- 注意栈空间限制，避免栈溢出
- 在性能关键路径上优先使用栈内存
- 大对象必须使用堆内存

## 静态内存

**是什么？在哪用？**
- **作用**：在编译期确定大小的内存，分配在全局数据区域
- **应用场景**：
  - 高性能场景：当需要高性能运行程序的时候，这部分程序所用的内存推荐使用静态内存
  - 固定大小的数据结构、常量数据等
  - 全局配置、单例对象等

### 特点

- **分配位置**：分配在全局数据区域
  - 有大小限制
  - 包含：全局变量、静态变量和常量
- **固定大小**：编译期大小就确定了
- **速度较快**：访问速度快
- **冗余使用**：可能造成内存浪费

## 生命期

- 生命周期与整个程序运行时间相关

**会遇到哪些问题？用什么解决？**
- **内存浪费**
  - **问题**：静态内存大小固定，可能造成内存浪费
  - **解决方向**：
    - 合理设计静态内存大小
    - 对于不常用的数据，考虑使用动态内存
    - 使用静态内存池管理多个对象

- **初始化顺序**
  - **问题**：全局变量的初始化顺序可能不确定
  - **解决方向**：
    - 避免全局变量之间的依赖
    - 使用单例模式延迟初始化
    - 使用初始化函数明确初始化顺序

- **线程安全**
  - **问题**：全局变量在多线程环境下需要同步
  - **解决方向**：
    - 使用锁保护全局变量访问
    - 使用线程局部存储（如果适用）
    - 使用无锁数据结构（如果适用）

**要点和思考方向**
- 静态内存访问速度快，适合高性能场景
- 注意内存浪费问题，合理设计大小
- 注意全局变量的初始化顺序和线程安全
- 固定大小的数据结构优先使用静态内存

### 动态内存

**是什么？在哪用？**
- **作用**：运行时动态分配的内存，提供灵活的内存管理
- **应用场景**：
  - 运行时大小不确定的数据结构
  - 需要动态增长的数据（如动态数组）
  - 对象的生命周期不确定的情况

### 特点

- **分配位置**：在堆（Heap）上分配
- **按需分配**：运行时根据需要分配
- **灵活**：运行时动态调整内存的分配和释放

### 生命期

- 开发者控制
- 运行时确定
- 例如C++，new时分配，delete时释放

**会遇到哪些问题？用什么解决？**
- **内存泄漏**
  - **问题**：忘记释放内存导致内存泄漏
  - **解决方向**：
    - 使用智能指针（C++）或RAII模式
    - 成对使用分配和释放函数
    - 使用内存分析工具检测泄漏
    - 建立内存泄漏检测机制

- **野指针**
  - **问题**：释放后继续使用导致程序崩溃
  - **解决方向**：
    - 释放后立即将指针设为nullptr
    - 使用智能指针自动管理
    - 避免多个指针指向同一块内存
    - 使用引用计数管理共享内存

- **碎片化**
  - **问题**：频繁分配释放导致内存碎片
  - **解决方向**：
    - 使用内存池减少碎片
    - 使用固定大小的内存块
    - 减少频繁的小块内存分配
    - 使用对象池复用对象

- **双重释放**
  - **问题**：同一块内存被释放两次，导致程序崩溃
  - **解决方向**：
    - 释放后立即将指针设为nullptr
    - 使用智能指针自动管理
    - 检查指针是否为nullptr再释放

**要点和思考方向**
- 动态内存提供灵活性，但需要手动管理
- 注意内存泄漏、野指针、双重释放等问题
- 使用智能指针和RAII模式简化管理
- 注意内存碎片化，使用内存池和对象池

## GC（垃圾回收）

**是什么？在哪用？**
- **作用**：对于高级语言，有垃圾回收机制，自动管理内存，减少内存泄漏风险
- **应用场景**：
  - Java、C#、Go、JavaScript等有GC的语言
  - 适合快速开发，减少内存管理负担
  - 不适合实时性要求极高的场景

**会遇到哪些问题？用什么解决？**
- **GC暂停（STW）**
  - **问题**：垃圾回收可能导致程序暂停（Stop The World），影响实时性
  - **解决方向**：
    - 减少对象分配，降低GC频率
    - 使用对象池复用对象
    - 避免大对象分配
    - 调整GC参数（如果支持）
    - 使用并发GC算法（如果支持）

- **内存泄漏**
  - **问题**：即使有GC，仍然可能出现内存泄漏（如循环引用、未释放资源）
  - **解决方向**：
    - 避免循环引用
    - 及时释放资源（文件、网络连接等）
    - 使用弱引用（WeakReference）打破循环引用
    - 使用IDisposable模式（C#）
    - 定期检查内存使用情况

- **性能问题**
  - **问题**：依然不能随便的使用内存，错误的使用，还是会造成性能或者泄漏问题
  - **解决方向**：
    - 合理使用内存，避免不必要的对象创建
    - 注意循环引用等
    - 减少临时对象创建
    - 使用值类型替代引用类型（如果适用）
    - 预分配容器大小，避免频繁扩容

- **GC压力**
  - **问题**：频繁的GC影响性能
  - **解决方向**：
    - 减少对象分配
    - 使用对象池
    - 避免在性能关键路径上分配内存
    - 使用栈内存替代堆内存（如果适用）

### 算法

**是什么？在哪用？**
- **作用**：不同的GC算法有不同的特点和适用场景
- **应用场景**：根据语言和运行时的实现选择

### 算法类型

- **复制算法（Copying GC）**
  - **结构**：使用两个堆空间，From空间用于分配内存，To空间用于转移活跃对象
  - **特点**：速度快，但内存利用率低（需要两倍空间）
  - **适用场景**：新生代回收

- **标记清除（Mark-Sweep GC）**
  - **结构**：多条链表及树形链表
  - **分配策略**：best-fit
  - **特点**：
    - 内存利用率高
    - 内存碎片化严重
  - **适用场景**：老年代回收

- **标记压缩（Mark-Compact GC）**
  - **特点**：
    - 效率相对低
    - 内存连续
  - **适用场景**：需要连续内存的场景

- **分代收集算法**
  - **原理**：根据对象的生命周期采用不同的回收策略
  - **目标**：优化垃圾回收性能，减少回收的成本
  - **特点**：
    - 针对不同生命周期的对象采用不同的回收策略，提高了回收效率
    - 避免了全堆扫描，减少了垃圾回收的停顿时间
    - 延迟了老年代的回收，降低了回收的频率
  - **适用场景**：大多数现代GC实现

**要点和思考方向**
- GC自动管理内存，但仍有性能影响和泄漏风险
- 减少对象分配，降低GC频率和压力
- 注意循环引用和资源释放
- 理解不同GC算法的特点，合理使用内存
- 在性能关键路径上优化GC压力

## 游戏开发中的应用

**是什么？在哪用？**
- **作用**：游戏开发中内存使用相对明确，可以预先规划，选择合适的 memory管理方案
- **应用场景**：所有游戏开发项目

### 内存规划

**是什么？在哪用？**
- **作用**：预先规划内存使用，提高效率和稳定性
- **应用场景**：游戏开发的所有阶段

#### 规划内容

- **内存预算**：比如各大系统的内存预算是多少
- **预留策略**：有哪些可以预先分批（预留），预留多少
- **动态分配**：有哪些是动态分配、释放的

**会遇到哪些问题？用什么解决？**
- **内存预算不准确**
  - **问题**：内存预算设置不当，导致内存不足或浪费
  - **解决方向**：
    - 通过实际测试统计内存使用
    - 为每个系统设置合理的预算
    - 预留一定的缓冲空间
    - 定期监控和调整预算

- **内存分配时机不当**
  - **问题**：在游戏循环中分配内存，导致卡顿
  - **解决方向**：
    - 在加载阶段预分配内存
    - 使用内存池和对象池
    - 避免在游戏循环中分配内存
    - 延迟分配，批量处理

### 方案选择

**是什么？在哪用？**
- **作用**：根据不同的需求选择合适的内存管理方案
- **应用场景**：游戏开发的架构设计阶段

#### 选择原则

- 选择内存尽量连续、使用和执行效率高的内存管理方案
- 也可以针对不同的系统使用不同的方案

### 实践建议

- **为不同系统制定内存预算**
  - 渲染系统、物理系统、音频系统等分别设置预算
  - 预留系统间共享的内存空间

- **使用内存池管理频繁分配释放的对象**
  - 粒子系统、特效系统等
  - 网络数据包处理
  - 临时缓冲区

- **静态内存用于固定大小的数据结构**
  - 配置数据
  - 常量数据
  - 全局单例对象

- **动态内存用于运行时不确定大小的数据**
  - 动态加载的资源
  - 用户生成的内容
  - 运行时创建的对象

**要点和思考方向**
- 游戏开发中内存使用相对明确，可以预先规划
- 为不同系统制定内存预算，预留缓冲空间
- 使用内存池和对象池管理频繁分配释放的对象
- 避免在游戏循环中分配内存
- 根据系统特点选择合适的内存管理方案

## 更多资料

### 问答资料
* [如何设计内存池？](https://www.zhihu.com/question/25527491/answer/2629173868)
