<h2 align="center">数据结构</h2>
<p>
在程序世界，数据的存储和操作，都可以被抽象成几种常用的结构。
</p>

**关键词:**<br/>
*数据结构,树,图,链表,顺序表,哈希,栈,队列,堆*

**标签:**<br/>
*等级: 初级|中级, 阶段: 学习|开发, 分类: 基础能力, 角色: 客户端开发|服务端开发|全栈开发*

----
## 线性表

### 顺序/数组（Array）

### 是什么？在哪用？

- **作用**：连续内存存储的线性数据结构，支持随机访问
- **应用场景**：
  - 一次性分配的数据，分配后不太变动了
  - 需要随机访问的场景
  - 固定大小的数据集合
- **优势**：
  - 可以随机访问任意元素（O(1)）
  - 实现简单
  - 内存连续，缓存友好

### 会遇到哪些问题？用什么解决？

- **中间插入或删除效率低**
  - **问题**：在中间插入或删除元素，需要移动后续元素，效率很低（O(n)）
  - **解决方向**：
    - 如果需要频繁在中间插入删除，考虑使用链表
    - 如果只在末尾操作，使用数组即可
    - 使用标记删除，延迟整理

- **尺寸有限**
  - **问题**：数组大小固定，扩展需要重新分配
  - **解决方向**：
    - 使用动态数组（如C++的vector）或预先分配足够大的空间
    - 使用 `reserve()` 预分配空间，减少重新分配
    - 预估最大容量，一次性分配

- **内存浪费**
  - **问题**：预分配的空间可能用不完，造成浪费
  - **解决方向**：
    - 合理预估容量
    - 使用动态数组，按需扩展
    - 定期整理，释放多余空间

### 要点和思考方向

- 数组适合随机访问，不适合频繁插入删除
- 使用动态数组时，预分配空间提高性能
- 注意内存浪费问题，合理预估容量

### 链表（Linked List）

### 是什么？在哪用？

- **作用**：通过指针连接的节点序列，支持动态插入删除
- **应用场景**：
  - 需要频繁变化的线性数据存储
  - 需要频繁在中间插入删除的场景
  - 不确定大小的数据集合
- **优势**：
  - 适合动态的伸缩数据
  - 删除中间的数据不用去移动前后数据（O(1)）
  - 因为都是动态分配，内存用多少就分多少
- **举例**：GC内存管理

### 会遇到哪些问题？用什么解决？

- **额外存储开销**
  - **问题**：要有额外存储节点信息的数据（指针）
  - **影响**：内存使用量增加
  - **解决方向**：
    - 对于小对象，考虑使用数组
    - 使用对象池减少分配开销
    - 使用紧凑的节点结构

- **无法快速定位**
  - **问题**：无法通过索引快速定位到元素，需要遍历（O(n)）
  - **影响**：查找效率低，需要遍历
  - **解决方向**：
    - 如果需要频繁查找，考虑使用哈希表
    - 维护索引或缓存常用节点
    - 使用跳表（Skip List）提高查找效率

- **实现复杂**
  - **问题**：实现相对复杂，需要管理指针，容易出错
  - **解决方向**：
    - 使用标准库提供的链表实现（如C++的list）
    - 使用智能指针管理内存
    - 添加边界检查和断言

- **缓存不友好**
  - **问题**：节点分散在内存中，缓存命中率低
  - **解决方向**：
    - 对于性能关键路径，考虑使用数组
    - 使用内存池分配连续节点
    - 使用数组链表混合结构

### 要点和思考方向

- 链表适合频繁插入删除，不适合随机访问
- 注意内存开销和缓存性能问题
- 使用标准库实现，避免手动管理指针
- 在性能关键路径上，考虑使用数组替代

### 栈（Stack）

### 是什么？在哪用？

- **作用**：后进先出（LIFO - Last In First Out）的线性数据结构
- **应用场景**：
  - 需要后进先出顺序的场景
  - 递归算法的非递归实现
  - 表达式求值
  - 可用于实现遍历树状结构

### 应用举例

- 函数调用栈
- 表达式求值
- 撤销操作
- 括号匹配
- 深度优先搜索（DFS）

### 会遇到哪些问题？用什么解决？

- **栈溢出**
  - **问题**：栈空间有限，深度递归可能导致栈溢出
  - **解决方向**：
    - 限制栈的深度
    - 使用迭代替代递归
    - 增加栈空间（如果可能）
    - 使用堆栈（手动管理）

- **性能问题**
  - **问题**：频繁的入栈出栈可能影响性能
  - **解决方向**：
    - 使用数组实现栈，避免动态分配
    - 预分配栈空间
    - 使用对象池复用栈对象

### 要点和思考方向

- 栈适合后进先出的场景
- 注意栈溢出问题，限制深度或使用迭代
- 使用数组实现栈，提高性能

### 队列（Queue）

### 是什么？在哪用？

- **作用**：先进先出（FIFO - First In First Out）的线性数据结构
- **应用场景**：
  - 需要先进先出顺序的场景
  - 消息管理
  - 任务调度
  - 缓冲区管理

### 应用举例

- 任务调度
- 消息队列
- 广度优先搜索（BFS）
- 打印队列
- 网络数据包缓冲

### 会遇到哪些问题？用什么解决？

- **队列溢出**
  - **问题**：队列空间有限，可能溢出
  - **解决方向**：
    - 使用循环队列（Circular Queue）
    - 动态扩展队列大小
    - 使用阻塞队列，等待空间可用
    - 丢弃旧数据（如果适用）

- **性能问题**
  - **问题**：频繁的入队出队可能影响性能
  - **解决方向**：
    - 使用数组实现循环队列
    - 预分配队列空间
    - 批量处理队列元素
    - 使用无锁队列（多线程场景）

- **优先级需求**
  - **问题**：普通队列不支持优先级
  - **解决方向**：
    - 使用优先队列（Priority Queue）
    - 使用堆实现优先队列
    - 使用多个队列按优先级管理

### 要点和思考方向

- 队列适合先进先出的场景
- 注意队列溢出问题，使用循环队列或动态扩展
- 需要优先级时使用优先队列
- 多线程场景考虑使用线程安全的队列

## 树（Tree）

### 是什么？在哪用？

- **作用**：分割/分类数据用的，层次化的数据结构
- **应用场景**：
  - 场景中静态物体的（空间）管理
  - 层次化数据组织
  - 快速查找和分类
  - **BVH（bounding volume hierarchy）**：层次包围盒

### 应用举例

- **场景可见性**：快速判断哪些物体在视野内
- **碰撞检测**：快速检测物体之间的碰撞
- **动画骨骼的管理**：管理角色的骨骼层次结构
- **文件系统**：目录树结构
- **数据库索引**：B树、B+树

### 会遇到哪些问题？用什么解决？

- **树不平衡**
  - **问题**：不平衡的树可能导致性能下降
  - **解决方向**：
    - 使用自平衡树（AVL树、红黑树）
    - 定期重新平衡树
    - 使用B树等平衡多路树

- **内存开销**
  - **问题**：树结构需要存储指针，内存开销较大
  - **解决方向**：
    - 使用数组实现完全二叉树
    - 使用紧凑的节点结构
    - 使用树池复用节点

- **更新复杂**
  - **问题**：树的更新操作可能复杂，需要维护树的性质
  - **解决方向**：
    - 使用标准库提供的树实现
    - 延迟更新，批量处理
    - 使用不可变树结构

### 要点和思考方向

- 树适合层次化数据组织和快速查找
- 注意树平衡问题，使用自平衡树
- 考虑内存开销，使用紧凑结构
- 使用标准库实现，避免手动维护

### 二叉树

### 是什么？在哪用？

- **作用**：每个节点最多有两个子节点的树结构
- **应用场景**：
  - 搜索、排序
  - 表达式树
  - 决策树
  - 二叉搜索树（BST）

### 会遇到哪些问题？用什么解决？

- **退化为链表**
  - **问题**：不平衡的二叉搜索树可能退化为链表
  - **解决方向**：
    - 使用自平衡二叉搜索树（AVL、红黑树）
    - 随机化插入顺序
    - 使用旋转操作保持平衡

### 要点和思考方向

- 二叉树简单高效，但要注意平衡问题
- 使用自平衡树避免退化
- 适合搜索和排序场景

### 多路查找树

### 是什么？在哪用？

- **作用**：每个节点可以有多个子节点的树结构
- **应用场景**：
  - 文件系统
  - 数据库索引（B树、B+树）
  - 字典树（Trie）

### 会遇到哪些问题？用什么解决？

- **节点分裂**
  - **问题**：节点满时需要分裂，操作复杂
  - **解决方向**：
    - 使用成熟的B树实现
    - 合理设置节点大小
    - 使用批量操作减少分裂

### 要点和思考方向

- 多路树适合大量数据的索引
- B树、B+树适合数据库索引
- 字典树适合字符串匹配

### 堆（Heap）

### 是什么？在哪用？

- **作用**：一种特殊的完全二叉树，满足堆性质（父节点大于/小于子节点）
- **应用场景**：
  - 优先队列
  - 堆排序
  - 任务调度
  - Top K问题

### 会遇到哪些问题？用什么解决？

- **堆化开销**
  - **问题**：插入删除需要堆化，有一定开销
  - **解决方向**：
    - 批量操作减少堆化次数
    - 使用斐波那契堆（如果适用）
    - 预分配堆空间

- **不支持随机访问**
  - **问题**：堆不支持快速查找任意元素
  - **解决方向**：
    - 如果需要查找，考虑使用其他数据结构
    - 使用哈希表辅助查找
    - 使用索引堆

### 要点和思考方向

- 堆适合优先队列和Top K问题
- 使用数组实现堆，提高性能
- 注意堆化开销，批量操作优化

## 哈希表（Hash）

### 是什么？在哪用？

- **作用**：哈希表（Hash table），也叫散列表，是一种基于哈希函数（Hash function）实现的数据结构，能够实现快速的插入、查找和删除操作（平均O(1)）
- **应用场景**：
  - 需要快速查找的场景
  - 键值对映射
  - 去重操作
  - 缓存实现
- **特点**：哈希表通过将关键字映射到表中一个位置来访问记录，以达到快速访问的目的

### 应用

- **文件变化检查**：快速检查文件是否被修改
- **ID映射关系**：快速通过ID查找对应的对象
- **缓存系统**：快速查找缓存数据
- **去重操作**：快速判断元素是否存在

### 会遇到哪些问题？用什么解决？

- **哈希冲突**
  - **问题**：不同的关键字可能映射到同一个位置
  - **解决方向**：
    - 使用开放寻址法（线性探测、二次探测）
    - 使用链地址法（拉链法）
    - 使用再哈希法
    - 选择合适的负载因子

- **哈希函数选择**
  - **问题**：不好的哈希函数可能导致冲突过多，影响性能
  - **解决方向**：
    - 选择分布均匀的哈希函数
    - 使用加密哈希函数（如MD5、SHA）的简化版本
    - 根据数据特点选择哈希函数
    - 使用标准库提供的哈希函数

- **动态扩容**
  - **问题**：哈希表需要动态扩容，可能影响性能
  - **解决方向**：
    - 预分配足够大的空间
    - 使用渐进式扩容
    - 合理设置负载因子阈值
    - 批量操作减少扩容次数

- **内存开销**
  - **问题**：哈希表需要额外的空间存储哈希值和指针
  - **解决方向**：
    - 使用紧凑的哈希表实现
    - 合理设置初始容量
    - 使用开放寻址法减少指针开销

### 要点和思考方向

- 哈希表提供O(1)平均时间复杂度的查找
- 注意哈希冲突问题，选择合适的冲突解决方法
- 选择好的哈希函数，减少冲突
- 合理设置负载因子，平衡空间和时间

## 图（Graph）

### 是什么？在哪用？

- **作用**：由节点（也称为顶点）和边组成的数据结构，用于表示节点之间的关系
- **应用场景**：
  - 状态管理
  - 网络拓扑
  - 路径规划
  - 依赖关系
- **特点**：节点之间的边描述了节点之间的关系，例如连通性、权重等

### 应用举例

- **角色状态管理**：角色在不同状态之间的转换
- **游戏状态管理**：游戏在不同状态之间的转换（如菜单、游戏中、暂停等）
- **寻路算法**：地图中的路径查找
- **社交网络**：用户之间的关系
- **依赖关系**：任务之间的依赖

### 会遇到哪些问题？用什么解决？

- **遍历效率**
  - **问题**：图的遍历可能很耗时，特别是大图
  - **解决方向**：
    - 使用深度优先搜索（DFS）或广度优先搜索（BFS），根据场景选择合适算法
    - 使用启发式搜索（A*算法）
    - 使用并行遍历（如果适用）
    - 缓存遍历结果

- **存储方式**
  - **问题**：图的存储方式影响操作效率
  - **解决方向**：
    - 根据使用场景选择邻接矩阵或邻接表
    - 稠密图使用邻接矩阵，稀疏图使用邻接表
    - 使用压缩存储（如果适用）
    - 使用图数据库（大规模场景）

- **内存开销**
  - **问题**：大图可能占用大量内存
  - **解决方向**：
    - 使用稀疏矩阵存储
    - 使用图压缩技术
    - 分块加载图数据
    - 使用图数据库

- **算法复杂度**
  - **问题**：图算法可能很复杂，时间复杂度高
  - **解决方向**：
    - 使用近似算法（如果适用）
    - 使用并行算法
    - 优化算法实现
    - 使用图算法库

### 要点和思考方向

- 图适合表示复杂的关系网络
- 根据图的稠密程度选择合适的存储方式
- 注意遍历效率，选择合适的算法
- 大规模图考虑使用图数据库

## 更多资料

### 电子文档
* [Data Structures and Algorithms for Game Developers.pdf](https://doc.lagout.org/science/0_Computer%20Science/2_Algorithms/Data%20Structures%20and%20Algorithms%20for%20Game%20Developers.pdf)
* [Data Structures for Game Programmers](https://cdn.preterhuman.net/texts/math/Data_Structure_And_Algorithms/Data%20Structure%20For%20Game%20Programers%20-%20Ron%20Penton.pdf)

### 视频资料
* [Understanding and implementing a Hash Table (in C)](https://www.youtube.com/watch?v=2Ti5yvumFTU) - 一个详细讲解哈希表和其实现的视频。

### 问答
* [What are the most widely used Data Structures & Algorithms in Game Development?](https://www.reddit.com/r/gamedev/comments/4zvxau/what_are_the_most_widely_used_data_structures/)