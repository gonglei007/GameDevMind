<h2 align="center">设计模式</h2>
<p>
程序开发的一项内功，合理的使用/选用设计模式（不滥用），能让系统更健壮、更易读、更易用。
</p>

**关键词:**<br/>
*设计模式,GOF,MVC,ASync,Delegate,Singleton,State,Factory,Observer,ECS*

**标签:**<br/>
*等级: 中级, 阶段: 学习|开发, 分类: 基础能力, 角色: 客户端开发|服务端开发|全栈开发*

----
## 单件（Singleton）

**是什么？在哪用？**
- **作用**：确保一个类只有一个实例，并提供全局访问点
- **应用场景**：
  - 全局访问一个单一的实例
  - 需要全局唯一对象的场景
  - 各个基础系统（GameSystem、SoundSystem等）
- **特点**：不需要管理这个实例的生命期，也就不需要预先设定在什么时候实例化

## 应用举例

- **各个基础系统**：
  - GameSystem
  - SoundSystem
  - ResourceManager
  - NetworkManager

**会遇到哪些问题？用什么解决？**
- **线程安全**
  - **问题**：多线程环境下可能创建多个实例
  - **解决方向**：
    - 使用双重检查锁定（Double-Checked Locking）
    - 使用静态初始化（Eager Initialization）
    - 使用线程局部存储（Thread Local Storage）
    - 使用原子操作（Atomic Operations）

- **测试困难**
  - **问题**：单例模式使单元测试变得困难，难以模拟和替换
  - **解决方向**：
    - 使用依赖注入替代单例
    - 提供设置实例的方法（用于测试）
    - 使用接口抽象，便于测试时替换实现

- **全局状态**
  - **问题**：单例模式引入全局状态，可能导致隐藏的依赖关系
  - **解决方向**：
    - 明确单例的职责和依赖关系
    - 避免单例之间的循环依赖
    - 考虑使用依赖注入替代

- **生命周期管理**
  - **问题**：单例的生命周期与程序相同，难以控制销毁时机
  - **解决方向**：
    - 提供显式的销毁方法
    - 使用智能指针管理生命周期（C++）
    - 在程序退出时清理资源

**要点和思考方向**
- 单例模式适合全局唯一的对象，但要谨慎使用
- 注意线程安全问题，使用合适的实现方式
- 考虑测试和维护性，避免过度使用单例
- 如果不使用单例，就需要搞清楚系统的流程和依赖，知道什么时候要去实例化这些系统

## 状态机（State）

**是什么？在哪用？**
- **作用**：管理对象的状态转换，将不同状态的行为封装在独立的状态类中
- **应用场景**：
  - 对象有多个状态，且状态转换逻辑复杂
  - 需要清晰管理状态转换的场景
- **有限状态机（FSM）**：
  - **状态**：
    - 进入状态（OnEnter）
    - 状态更新（OnUpdate）
    - 离开状态（OnExit）
  - **迁移**：状态之间的转换

## 应用举例

- 网络状态管理（连接中、已连接、断开等）
- 登录状态管理（未登录、登录中、已登录等）
- 游戏房间管理（等待中、游戏中、结算中等）
- 角色行为（待机、移动、攻击、死亡等）
- 动画管理（播放、暂停、停止等）

**会遇到哪些问题？用什么解决？**
- **状态数量爆炸**
  - **问题**：当行为复杂时，状态数量会急剧增加，导致状态机难以维护
  - **解决方向**：
    - 使用分层状态机（Hierarchical State Machine）
    - 使用行为树（Behavior Tree）等更灵活的行为管理方式
    - 合并相似状态，减少状态数量
    - 使用状态组合而非单一状态

- **状态转换逻辑复杂**
  - **问题**：多个状态之间的转换条件可能相互影响，导致逻辑混乱
  - **解决方向**：
    - 明确状态转换条件，使用状态转换表管理
    - 避免循环依赖
    - 使用状态转换事件而非直接转换
    - 提供状态转换的验证机制

- **状态数据共享**
  - **问题**：不同状态之间需要共享数据，可能导致耦合
  - **解决方向**：
    - 使用上下文对象（Context）共享数据
    - 通过状态参数传递数据
    - 使用全局状态管理器

- **性能问题**
  - **问题**：频繁的状态转换可能影响性能
  - **解决方向**：
    - 优化状态转换逻辑
    - 使用状态池复用状态对象
    - 避免在状态转换中进行耗时操作

**要点和思考方向**
- 状态机适合管理有明确状态转换的对象
- 注意状态数量爆炸问题，使用分层状态机或行为树
- 明确状态转换条件，避免逻辑混乱
- 如果不使用状态机，就需要层层嵌套的、极度复杂的if或者switch判断来实现，这让本来只有一个切换关系的不同状态的代码都搅和在一起，让代码的可读性、可维护性都变得很差

## 工厂（Factory）

**是什么？在哪用？**
- **作用**：将对象的创建过程封装在工厂类中，客户端只需要通过工厂类来获取所需的对象实例，无需关心具体的创建过程
- **应用场景**：
  - 需要根据条件创建不同类型的对象
  - 对象创建过程复杂，需要封装
  - 需要统一管理对象创建

## 应用举例

- **第三方中间件接入**：统一管理不同中间件的创建

- **对象池**：
  - 在对象池中，我们需要创建多个对象实例，并在需要时从池中取出一个对象，使用完后再将其放回池中。这个过程可以使用工厂模式来实现，通过工厂类来创建和管理对象池中的对象实例

- **资源管理器**：
  - 在游戏开发中，我们需要加载和管理大量的资源文件，例如图片、音频、模型等。为了提高资源的使用效率和性能，我们通常会使用资源管理器来管理和加载资源。资源管理器可以使用工厂模式来实现，通过工厂类来创建和管理不同类型的资源对象

- **实体组件**：
  - 在游戏中，每个物体通常都由多个组件组成，例如渲染组件、碰撞组件、动画组件等。这些组件的创建和管理可以使用工厂模式来实现，通过工厂类来创建和管理不同类型的组件对象

**会遇到哪些问题？用什么解决？**
- **工厂类膨胀**
  - **问题**：随着产品类型增加，工厂类可能变得庞大
  - **解决方向**：
    - 使用抽象工厂模式
    - 使用工厂方法模式，每个产品有自己的工厂
    - 使用注册机制动态注册工厂

- **扩展困难**
  - **问题**：添加新产品类型需要修改工厂类
  - **解决方向**：
    - 使用反射机制动态创建对象
    - 使用配置文件定义产品类型
    - 使用依赖注入框架

- **类型安全**
  - **问题**：工厂返回的对象类型可能不明确
  - **解决方向**：
    - 使用泛型工厂
    - 使用接口或基类定义产品类型
    - 提供类型检查机制

**要点和思考方向**
- 工厂模式封装对象创建过程，提高代码的可维护性
- 注意工厂类的膨胀问题，使用合适的工厂模式变体
- 考虑扩展性，使用配置或反射机制
- 确保类型安全，使用接口或泛型

## 发布（Publish）/订阅（Subscribe）

**是什么？在哪用？**
- **作用**：
  - 让系统完全解耦
  - 当消息发布出来后，消息的处理者不用立即响应，可以根据当前自身情况从队列中取出消息来处理
  - 当消息发不出来后，消息的发布者也不用等待消息处理者去完成处理
- **应用场景**：
  - 需要解耦的系统间通信
  - 一对多的消息通知
  - 异步事件处理

## 好处

- 各个系统更独立，运算量更明确，性能更可控

## 应用举例

- 服务端的消息队列
- 游戏事件系统
- UI事件通知
- 日志系统

**会遇到哪些问题？用什么解决？**
- **消息丢失**
  - **问题**：订阅者可能错过消息，特别是订阅者未启动时
  - **解决方向**：
    - 使用持久化消息队列
    - 提供消息重放机制
    - 使用消息确认机制

- **性能问题**
  - **问题**：大量订阅者可能导致性能问题
  - **解决方向**：
    - 使用异步消息处理
    - 限制订阅者数量
    - 使用消息过滤机制
    - 优化消息分发算法

- **调试困难**
  - **问题**：发布订阅模式使消息流向不明确，难以调试
  - **解决方向**：
    - 添加消息日志
    - 使用消息追踪工具
    - 提供消息可视化工具

- **循环依赖**
  - **问题**：订阅者之间可能形成循环依赖
  - **解决方向**：
    - 明确消息流向
    - 使用消息优先级
    - 避免循环订阅

**要点和思考方向**
- 发布订阅模式实现系统解耦，提高可维护性
- 注意消息丢失和性能问题
- 提供调试工具，便于追踪消息流向
- 避免循环依赖，明确消息流向

## 命令模式（Command Pattern）

**是什么？在哪用？**
- **作用**：将请求封装为对象，使请求的参数化、队列化、日志化、撤销/重做成为可能
- **应用场景**：
  - 需要支持撤销/重做的操作
  - 需要将操作记录到日志
  - 需要支持宏命令（组合命令）
  - GUI工具的开发

## 应用

- 经常会被用在各种GUI工具的开发中
- 游戏中的撤销/重做功能
- 操作历史记录
- 宏命令系统

**会遇到哪些问题？用什么解决？**
- **命令对象过多**
  - **问题**：每个操作都需要创建命令对象，可能产生大量对象
  - **解决方向**：
    - 使用命令对象池
    - 使用轻量级命令对象
    - 合并相似命令

- **撤销/重做实现复杂**
  - **问题**：实现撤销/重做功能需要保存状态，可能复杂
  - **解决方向**：
    - 使用备忘录模式保存状态
    - 使用命令模式本身保存状态
    - 限制撤销/重做的深度

- **性能问题**
  - **问题**：命令模式可能增加性能开销
  - **解决方向**：
    - 优化命令执行逻辑
    - 使用命令队列批量处理
    - 避免不必要的命令对象创建

**要点和思考方向**
- 命令模式支持撤销/重做和操作记录
- 注意命令对象过多的问题，使用对象池
- 实现撤销/重做需要合理设计状态保存机制
- 适合需要操作历史的场景

## 观察者（Observer）

**是什么？在哪用？**
- **作用**：让两个系统没有耦合在一起的情况下，进行交互（一个系统的自身发生的变化，让另一个系统知道和做出响应）
- **应用场景**：
  - 事件、变化通知等
  - 需要一对多依赖关系的场景
  - 需要解耦的观察者和被观察者

## 应用

- 事件、变化通知等

## 应用举例

- 例如网络系统的状态变化
- MVC中的View对Model的变化的监听与响应
- UI更新通知
- 数据变化通知

**会遇到哪些问题？用什么解决？**
- **内存泄漏**
  - **问题**：观察者未正确取消订阅，可能导致内存泄漏
  - **解决方向**：
    - 使用弱引用（Weak Reference）
    - 在对象销毁时自动取消订阅
    - 使用RAII模式管理订阅生命周期

- **通知顺序不确定**
  - **问题**：多个观察者的通知顺序可能不确定
  - **解决方向**：
    - 使用优先级机制
    - 明确通知顺序规则
    - 使用同步机制保证顺序

- **性能问题**
  - **问题**：大量观察者可能导致性能问题
  - **解决方向**：
    - 使用异步通知
    - 批量通知
    - 限制观察者数量
    - 优化通知机制

- **循环通知**
  - **问题**：观察者可能触发被观察者的变化，导致循环通知
  - **解决方向**：
    - 避免在通知中修改被观察者
    - 使用标志位防止循环
    - 延迟通知

**要点和思考方向**
- 观察者模式实现解耦，提高可维护性
- 注意内存泄漏问题，正确管理订阅生命周期
- 明确通知顺序，避免循环通知
- 如果不使用观察者模式，各个系统/模块之间直接访问调用，会让它们形成相互的依赖，除了可读性变差、复杂度变高以外，让这些系统/模块的易维护性变差，因为这些"相互依赖"，当动一个系统/模块的时候，就要考虑对另外的关联系统/模块的影响（本来它们可以互不相干）

## MVC

**是什么？在哪用？**
- **作用**：将应用程序分为三个部分：Model（模型）、View（视图）、Controller（控制器），实现关注点分离
- **好处**：让程序更清晰，让思路更聚焦，让代码更可读。做表现就聚焦表现细节。做业务逻辑就聚焦业务逻辑
- **使用场景**：有表现和交互的业务功能的开发
  - **举例**：
    - 好友功能
    - 排行榜功能
    - 投票功能

## 实践

- **Model**
  - **作用**：业务中相关的数据模型
  - **接口**：
    - 提供改变数据的接口
    - 提供数据变化时的一些事件触发

- **View**
  - **作用**：纯粹跟表现相关的实现
  - **举例**：
    - 页面的动态表现
    - 页面上部件的更新
  - **注意**：尽量不要在里面做业务逻辑实现或者业务部分数据存储（可以放跟表现相关的数据），这会让系统的可读性非常的差

- **Controller**
  - **作用**：业务逻辑的实现
  - **举例**：向服务器发出请求
  - **注意**：业务逻辑的一些响应需要刷新View的时候，调用View的接口来刷新

**会遇到哪些问题？用什么解决？**
- **Controller膨胀**
  - **问题**：随着业务逻辑增加，Controller可能变得庞大
  - **解决方向**：
    - 将复杂逻辑提取到Service层
    - 使用命令模式封装操作
    - 拆分Controller，按功能模块划分

- **View和Model耦合**
  - **问题**：View可能直接访问Model，导致耦合
  - **解决方向**：
    - 使用观察者模式，View监听Model变化
    - 通过Controller更新View
    - 使用ViewModel（MVVM模式）

- **数据同步问题**
  - **问题**：多个View可能显示同一Model，需要同步更新
  - **解决方向**：
    - 使用观察者模式通知所有View
    - 使用事件机制
    - 使用数据绑定

- **测试困难**
  - **问题**：MVC结构可能使单元测试变得困难
  - **解决方向**：
    - 使用依赖注入
    - 分离业务逻辑到Service层
    - 使用Mock对象测试

**要点和思考方向**
- MVC模式实现关注点分离，提高代码可维护性
- 注意Controller膨胀问题，合理拆分
- 避免View和Model直接耦合，通过Controller交互
- 如果不使用MVC，数据、逻辑、表现都有自己的复杂逻辑，所有这些都交织在一起，让本可以清晰的各个模块，复杂度大幅增加。这会让后续维护的成本也大幅提升

## 异步流控制

**是什么？在哪用？**
- **作用**：为异步代码提供了一个结构化管理方式，避免回调地狱
- **应用场景**：
  - 需要处理多个异步操作的场景
  - 需要控制异步操作执行顺序的场景
  - 需要并行执行异步操作的场景

## 好处

- 减少嵌套，让代码更可读
- 提供统一的错误处理机制
- 支持复杂的异步流程控制

## 举例

- **waterfall**：顺序执行，前一个操作的结果作为下一个操作的输入
- **foreach**：for循环执行，对数组中的每个元素执行异步操作
- **parallel**：并行执行多个异步操作
- **series**：顺序执行，不传递结果

## 补充

- 有些语言/库有集成的或者第三方的方案/中间件
- JavaScript: async库、Promise、async/await
- C#: Task、async/await
- Python: asyncio

**会遇到哪些问题？用什么解决？**
- **错误处理复杂**
  - **问题**：异步操作的错误处理可能复杂
  - **解决方向**：
    - 使用统一的错误处理机制
    - 使用try-catch配合async/await
    - 提供错误回调函数

- **性能问题**
  - **问题**：大量异步操作可能影响性能
  - **解决方向**：
    - 限制并发数量
    - 使用队列管理异步操作
    - 优化异步操作本身

- **调试困难**
  - **问题**：异步代码的调试可能困难
  - **解决方向**：
    - 使用调试工具支持异步调试
    - 添加日志记录异步操作
    - 使用Promise链式调用便于追踪

**要点和思考方向**
- 异步流控制提供结构化的异步代码管理方式
- 减少嵌套，提高代码可读性
- 注意错误处理和性能问题
- 如果不使用异步流控制，就要用层层嵌套的回调，代码的可读性会非常的差，影响工作效率

## ECS

**是什么？在哪用？**
- **作用**：将数据（Component）和逻辑（System）分离，通过组合（Entity）实现灵活的对象系统
- **概要**：在一定意义上，这个模式有些像是设计思想的一种回归。跟C语言中的"过程操作数据结构"有些相似。可以获得程序的高性能运行
- **应用场景**：
  - 游戏中有大量的对象需要去处理，就适合用ECS结构
  - 需要高性能的场景
  - 需要灵活组合对象的场景

## 构成

- **Entity**：游戏中的实体，可能包含多个component，通常只是一个ID
- **Component**：数据结构，纯数据，不包含逻辑
- **System**：逻辑系统，用于更新component数据，处理具有特定component组合的entity

## 应用

- 游戏中有大量的对象需要去处理，就适合用ECS结构
- 如果是更偏向于业务流程的功能，不建议用这个模型
- 适合需要高性能的场景，如物理模拟、渲染等

**会遇到哪些问题？用什么解决？**
- **学习曲线**
  - **问题**：ECS模式与传统的面向对象思维不同，学习曲线陡
  - **解决方向**：
    - 理解数据与逻辑分离的思想
    - 从简单场景开始使用
    - 参考成熟的ECS框架实现

- **组件查询性能**
  - **问题**：查找具有特定component组合的entity可能影响性能
  - **解决方向**：
    - 使用组件索引优化查询
    - 缓存查询结果
    - 使用稀疏集合（Sparse Set）等数据结构

- **系统执行顺序**
  - **问题**：多个System的执行顺序可能影响结果
  - **解决方向**：
    - 明确System之间的依赖关系
    - 使用依赖图管理执行顺序
    - 使用阶段（Phase）组织System

- **调试困难**
  - **问题**：数据与逻辑分离使调试变得困难
  - **解决方向**：
    - 提供可视化工具查看Entity和Component
    - 添加日志记录System执行
    - 使用调试器支持ECS结构

**要点和思考方向**
- ECS模式适合需要高性能和灵活组合的场景
- 理解数据与逻辑分离的思想
- 注意组件查询性能和系统执行顺序
- 不适合业务流程功能，更适合游戏对象系统

## 更多模式

**是什么？在哪用？**
- **原型模式**：通过复制现有实例来创建新实例
- **建造者模式**：将复杂对象的构建与其表示分离
- **代理模式**：为其他对象提供一种代理以控制对这个对象的访问
- **桥接模式**：将抽象部分与它的实现部分分离
- **外观模式**：为子系统中的一组接口提供一个统一的接口
- **中介者模式**：用一个中介对象来封装一系列的对象交互

## 更多资料

## 文章
* [The Entity-Component-System - An awesome game-design pattern in C++ (Part 1)](https://www.gamedeveloper.com/design/the-entity-component-system---an-awesome-game-design-pattern-in-c-part-1-)

## 在线电子书
* [《游戏编程模式》](https://gpp.tkchu.me)
* [《Game Programming Patterns》](http://gameprogrammingpatterns.com/contents.html)
* [《Game Design Patterns in Unity》](https://livebook.manning.com/book/game-programming-design-patterns/welcome/v-3/)

## 视频资料
* [10 Design Patterns Explained in 10 Minutes](https://www.youtube.com/watch?v=tv-_1er1mWI)
* [How To Build An Event System in Unity](https://www.youtube.com/watch?v=gx0Lt4tCDE0)