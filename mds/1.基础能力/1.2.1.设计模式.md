<h2 align="center">设计模式</h2>
<p>
程序开发的一项内功，合理的使用/选用设计模式（不滥用），能让系统更健壮、更易读、更易用。
</p>

**关键词:**<br/>
*设计模式,GOF,MVC,ASync,Delegate,Singleton,State,Factory,Observer,ECS*

**标签:**<br/>
*等级: 中级, 阶段: 学习|开发, 分类: 基础能力, 角色: 客户端开发|服务端开发|全栈开发*

----
## 单件（Singleton）

### 是什么？在哪用？

- **使用场景**：全局访问一个单一的实例
- **特点**：不需要管理这个实例的生命期，也就不需要预先设定在什么时候实例化

### 应用举例

- **各个基础系统**：
  - GameSystem
  - SoundSystem

### 会遇到哪些问题？用什么解决？

- **线程安全**
  - **问题**：多线程环境下可能创建多个实例
  - **解决方向**：使用双重检查锁定、静态初始化等方式确保线程安全

### 如果不使用

- 就需要搞清楚系统的流程和依赖，知道什么时候要去实例化这些系统

## 状态机（State）

### 是什么？在哪用？

- **有限状态机（FSM）**：
  - **状态**：
    - 进入状态
    - 状态更新
    - 离开状态
  - **迁移**：状态之间的转换

### 应用举例

- 网络状态管理
- 登录状态管理
- 游戏房间管理
- 角色行为
- 动画管理

### 如果不使用

- 就需要层层嵌套的、极度复杂的if或者switch判断来实现，这让本来只有一个切换关系的不同状态的代码都搅和在一起，让代码的可读性、可维护性都变得很差

## 工厂（Factory）

### 是什么？在哪用？

- **说明**：工厂模式可以将对象的创建过程封装在工厂类中，客户端只需要通过工厂类来获取所需的对象实例，无需关心具体的创建过程

### 应用举例

- **第三方中间件接入**：统一管理不同中间件的创建

- **对象池**：
  - 在对象池中，我们需要创建多个对象实例，并在需要时从池中取出一个对象，使用完后再将其放回池中。这个过程可以使用工厂模式来实现，通过工厂类来创建和管理对象池中的对象实例

- **资源管理器**：
  - 在游戏开发中，我们需要加载和管理大量的资源文件，例如图片、音频、模型等。为了提高资源的使用效率和性能，我们通常会使用资源管理器来管理和加载资源。资源管理器可以使用工厂模式来实现，通过工厂类来创建和管理不同类型的资源对象

- **实体组件**：
  - 在游戏中，每个物体通常都由多个组件组成，例如渲染组件、碰撞组件、动画组件等。这些组件的创建和管理可以使用工厂模式来实现，通过工厂类来创建和管理不同类型的组件对象

## 发布（Publish）/订阅（Subscribe）

### 是什么？在哪用？

- **作用**：
  - 让系统完全解耦
  - 当消息发布出来后，消息的处理者不用立即响应，可以根据当前自身情况从队列中取出消息来处理
  - 当消息发不出来后，消息的发布者也不用等待消息处理者去完成处理

### 好处

- 各个系统更独立，运算量更明确，性能更可控

### 应用举例

- 服务端的消息队列

## 命令模式（Command Pattern）

### 是什么？在哪用？

- **说明**：是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令

### 应用

- 经常会被用在各种GUI工具的开发中

## 观察者（Observer）

### 是什么？在哪用？

- **作用**：让两个系统没有耦合在一起的情况下，进行交互（一个系统的自身发生的变化，让另一个系统知道和做出响应）

### 应用

- 事件、变化通知等

### 应用举例

- 例如网络系统的状态变化
- MVC中的View对Model的变化的监听与响应

### 如果不使用

- 各个系统/模块之间直接访问调用，会让它们形成相互的依赖，除了可读性变差、复杂度变高以外，让这些系统/模块的易维护性变差，因为这些"相互依赖"，当动一个系统/模块的时候，就要考虑对另外的关联系统/模块的影响（本来它们可以互不相干）

## MVC

### 是什么？在哪用？

- **好处**：让程序更清晰，让思路更聚焦，让代码更可读。做表现就聚焦表现细节。做业务逻辑就聚焦业务逻辑

- **使用场景**：有表现和交互的业务功能的开发
  - **举例**：
    - 好友功能
    - 排行榜功能
    - 投票功能

### 实践

- **Model**
  - **作用**：业务中相关的数据模型
  - **接口**：
    - 提供改变数据的接口
    - 提供数据变化时的一些事件触发

- **View**
  - **作用**：纯粹跟表现相关的实现
  - **举例**：
    - 页面的动态表现
    - 页面上部件的更新
  - **注意**：尽量不要在里面做业务逻辑实现或者业务部分数据存储（可以放跟表现相关的数据），这会让系统的可读性非常的差

- **Controller**
  - **作用**：业务逻辑的实现
  - **举例**：向服务器发出请求
  - **注意**：业务逻辑的一些响应需要刷新View的时候，调用View的接口来刷新

### 如果不使用

- 数据、逻辑、表现都有自己的复杂逻辑，所有这些都交织在一起，让本可以清晰的各个模块，复杂度大福增加。这会让后续维护的成本也大幅提升

## 异步流控制

### 是什么？在哪用？

- **作用**：为异步代码提供了一个结构化管理方式

### 好处

- 减少嵌套，让代码更可读

### 举例

- **waterfall**：顺序执行
- **foreach**：for循环执行

### 补充

- 有些语言/库有集成的或者第三方的方案/中间件

### 如果不使用

- 就要用层层嵌套的回调，代码的可读性会非常的差，影响工作效率

## ECS

### 是什么？在哪用？

- **概要**：在一定意义上，这个模式有些像是设计思想的一种回归。跟C语言中的"过程操作数据结构"有些相似。可以获得程序的高性能运行

- **构成**：
  - **Entity**：游戏中的实体，可能包含多个component
  - **Component**：数据结构
  - **System**：逻辑系统，用于更新component数据

### 应用

- 游戏中有大量的对象需要去处理，就适合用ECS结构
- 如果是更偏向于业务流程的功能，不建议用这个模型

## 更多模式

### 是什么？在哪用？

- **原型模式**：通过复制现有实例来创建新实例
- **建造者模式**：将复杂对象的构建与其表示分离
- **代理模式**：为其他对象提供一种代理以控制对这个对象的访问
- **桥接模式**：将抽象部分与它的实现部分分离
- **外观模式**：为子系统中的一组接口提供一个统一的接口
- **中介者模式**：用一个中介对象来封装一系列的对象交互

## 更多资料

### 文章
* [The Entity-Component-System - An awesome game-design pattern in C++ (Part 1)](https://www.gamedeveloper.com/design/the-entity-component-system---an-awesome-game-design-pattern-in-c-part-1-)

### 在线电子书
* [《游戏编程模式》](https://gpp.tkchu.me)
* [《Game Programming Patterns》](http://gameprogrammingpatterns.com/contents.html)
* [《Game Design Patterns in Unity》](https://livebook.manning.com/book/game-programming-design-patterns/welcome/v-3/)

### 视频资料
* [10 Design Patterns Explained in 10 Minutes](https://www.youtube.com/watch?v=tv-_1er1mWI)
* [How To Build An Event System in Unity](https://www.youtube.com/watch?v=gx0Lt4tCDE0)